/*    
    Copyright 2013-2025 Onera.

    This file is part of Cassiopee.

    Cassiopee is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Cassiopee is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Cassiopee.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "Data.h"

void gmouseButton(int button, int etat, int x, int y)
{
  Data* d = Data::getInstance();
  d->mouseButton(button, etat, x, y);
}
void gmouseMotion(int x, int y)
{
  Data* d = Data::getInstance();
  d->mouseMotion(x, y);
}
void gmousePassiveMotion(int x, int y)
{
  // unused
  Data* d = Data::getInstance();
  d->mousePassiveMotion(x, y);
}

//=============================================================================
/* 
   Mouse.
   Controls events generated by mouse:
   In SHIFT mode:
   Clicking selects the active mouse plugin.
*/
//=============================================================================
void Data::mouseButton(E_Int button, E_Int etat, E_Int x, E_Int y)
{
  //ptrState->render = 1;
  if (etat == 1) 
  { ptrState->currentMouseButton = 5; ptrState->ondrag = 0; ptrState->render = 1; return; } // button released
  
  E_Int modif = glutGetModifiers();
  
  switch (button)
  {
    case GLUT_LEFT_BUTTON:
      
      // double click : center view
      if (ptrState->mouseFirstClicked > 0)
      {
        if (modif == (GLUT_ACTIVE_CTRL | GLUT_ACTIVE_SHIFT) ||
            modif == GLUT_ACTIVE_SHIFT ||
            modif == GLUT_ACTIVE_CTRL)
        {
          double dx = _view.xcam-_view.xeye;
          double dy = _view.ycam-_view.yeye;
          double dz = _view.zcam-_view.zeye;
          E_Int suiviDir = -1;
          if (fabs(dx) < 1.e-6 && fabs(dy) < 1.e-6) suiviDir = 1; // xy
          else if (fabs(dx) < 1.e-6 && fabs(dz) < 1.e-6) suiviDir = 2; // xz
          else if (fabs(dy) < 1.e-6 && fabs(dz) < 1.e-6) suiviDir = 3; // yz
          
          // center view
          _view.xeye = ptrState->activePointX;
          _view.yeye = ptrState->activePointY;
          _view.zeye = ptrState->activePointZ;
          ptrState->mouseFirstClicked = 0;

          if (suiviDir > 0) // cam doit suivre
          {
            switch (suiviDir)
            {
              case 1:
                _view.xcam = _view.xeye;
                _view.ycam = _view.yeye;
                break;
              case 2:
                _view.xcam = _view.xeye;
                _view.zcam = _view.zeye;
                break;
              case 3:
                _view.ycam = _view.yeye;
                _view.zcam = _view.zeye;
                break;
            }
          }
          ptrState->ondrag = 0;
          ptrState->render = 1;
        }
      }
      else
      {
        //printf("first click detected\n");
        ptrState->mouseFirstClicked = 1;
      }
      
      if (modif == (GLUT_ACTIVE_CTRL | GLUT_ACTIVE_SHIFT))
      {
        // Mouse multiple action
        if (_pref.mouseMultipleClick != NULL)
          _pref.mouseMultipleClick->f(this, button, etat, x, y);
        ptrState->render = 1;
      }
      else if (modif == GLUT_ACTIVE_SHIFT)
      {
        // Mouse click action
        if (_pref.mouseClick != NULL)
          _pref.mouseClick->f(this, button, etat, x, y);
        ptrState->render = 1;
      }
      else if (modif == GLUT_ACTIVE_CTRL)
      {
        // Mouse click accurate action
        if (_pref.mouseClick != NULL)
          _pref.mouseAccurateClick->f(this, button, etat, x, y);
        ptrState->render = 1;
      }
      break;

    case GLUT_RIGHT_BUTTON:
      if (modif == GLUT_ACTIVE_SHIFT)
      {
        // Reverse mouse click action
        if (_pref.mouseRightClick != NULL)
          _pref.mouseRightClick->f(this, button, etat, x, y);
        ptrState->render = 1;
      }
      break;

    case 3: // mouse wheel, zoom in
    {
      //double alpha = 0.08;
      double alpha = 0.15;
      double dx = (_view.xeye - _view.xcam)*alpha;
      double dy = (_view.yeye - _view.ycam)*alpha;
      double dz = (_view.zeye - _view.zcam)*alpha;
      double d = sqrt(dx*dx+dy*dy+dz*dz);
    
      _view.xcam += dx;
      _view.ycam += dy;
      _view.zcam += dz;
      if (d < epsup && ptrState->modifier == GLUT_ACTIVE_CTRL) 
      {
        // Recule le pts de vue en meme temps que l'on avance
        _view.xeye += dx;
        _view.yeye += dy;
        _view.zeye += dz;
      }
      
      adaptiveClipping(d);
      button = GLUT_MIDDLE_BUTTON;
      ptrState->render = 1;
    }

    case 4: // mouse wheel, zoom out
    {
      //double alpha = 0.04;
      double alpha = 0.075;
      double dx = (_view.xeye - _view.xcam)*alpha;
      double dy = (_view.yeye - _view.ycam)*alpha;
      double dz = (_view.zeye - _view.zcam)*alpha;
      double d = sqrt(dx*dx+dy*dy+dz*dz);

      _view.xcam = _view.xcam - dx;
      _view.ycam = _view.ycam - dy;
      _view.zcam = _view.zcam - dz;
      /*
      if (d > epsup*1.)
      { if (_view.clipping != 0) farClipping(); }
      else if (d > epsup*1.e-2)
      { if (_view.clipping != 1) closeClipping(); }
      else if (d > epsup*1.e-3)
      { if (_view.clipping != 2) veryCloseClipping(); }
      else
      { if (_view.clipping != 3) veryVeryCloseClipping(); }
      */
      adaptiveClipping(d);
      button = GLUT_MIDDLE_BUTTON;
      ptrState->render = 1;
    }
  }
  ptrState->activeMouseButton = button;
  ptrState->currentMouseButton = button;
  ptrState->activeMouseX = x;
  ptrState->activeMouseY = y;
  ptrState->modifier = modif;
}

//=============================================================================
// Called when moving mouse
void Data::mouseMotion(E_Int x, E_Int y)
{
  // Mouvement de la souris + shift = selection par mouse drag
  if (ptrState->modifier == GLUT_ACTIVE_SHIFT) { mouseDrag(x, y); return;}
  if (ptrState->modifier == (GLUT_ACTIVE_SHIFT | GLUT_ACTIVE_CTRL)) 
  { mouseDrag(x, y); return;}

  // Mouvement de la souris sans shift
  ptrState->ondrag = 1;
  ptrState->render = 1;

  // Zoom / dezoom
  if (ptrState->activeMouseButton == GLUT_MIDDLE_BUTTON)
  {
    double alpha = 0.004;
    double dx = (_view.xeye - _view.xcam)*alpha;
    double dy = (_view.yeye - _view.ycam)*alpha;
    double dz = (_view.zeye - _view.zcam)*alpha;
    double d = sqrt(dx*dx+dy*dy+dz*dz);
    
    if (ptrState->modifier == GLUT_ACTIVE_CTRL)
    {
      if (y > ptrState->activeMouseY+0.)
      {
        _view.xcam += dx;
        _view.ycam += dy;
        _view.zcam += dz;
        if (d < epsup) 
        {_view.xeye += dx;
         _view.yeye += dy;
         _view.zeye += dz;}
        if (d <= epsup*0.035 && _view.clipping == 0)
        { // change perspective
          closeClipping();
        }
      }
      else
      {
        _view.xcam -= dx;
        _view.ycam -= dy;
        _view.zcam -= dz;
        if (d > epsup*0.02 && _view.clipping == 1)
        { // change perspective
          farClipping();
        }
      }
      ptrState->activeMouseButton = GLUT_MIDDLE_BUTTON;
      ptrState->activeMouseX = x;
      ptrState->activeMouseY = y;
    }
    else
    {
      if (y < ptrState->activeMouseY)
      { 
        _view.xcam += dx;
        _view.ycam += dy;
        _view.zcam += dz;
        if (d <= epsup*0.035 && _view.clipping == 0)
        { // change perspective
          closeClipping();
        }
      }
      else
      {
        _view.xcam -= dx;
        _view.ycam -= dy;
        _view.zcam -= dz;
        if (d > epsup*0.02 && _view.clipping == 1)
        { // change perspective
          farClipping();
        }
      }
      ptrState->activeMouseButton = GLUT_MIDDLE_BUTTON;
      ptrState->activeMouseX = x;
      ptrState->activeMouseY = y;
    }
  }
  else if (ptrState->activeMouseButton == GLUT_LEFT_BUTTON)
  {
    double dx = (_view.xeye - _view.xcam);
    double dy = (_view.yeye - _view.ycam);
    double dz = (_view.zeye - _view.zcam);
    double d = sqrt(dx*dx + dy*dy + dz*dz);
    double alpha = 0.009;
    //alpha = MIN(0.0015+d/dmoy*0.0035, 0.005);
    //alpha = 0.005+d/dmoy*0.005;
    //alpha = MIN(0.000001+d/dmoy*0.0025, 0.005);
    alpha = 0.005+d/dmoy*0.008;
    dx = dx*alpha; dy = dy*alpha; dz = dz*alpha; d = d*alpha;

    double dirx = _view.dirx;
    double diry = _view.diry;
    double dirz = _view.dirz;
    if (ptrState->modifier == GLUT_ACTIVE_CTRL)
    {
      if (x > ptrState->activeMouseX+0.)
        rotateHeadLeft(alpha, dx, dy, dz, d, dirx, diry, dirz);
      else if (x < ptrState->activeMouseX-0.)
        rotateHeadRight(alpha, dx, dy, dz, d, dirx, diry, dirz);
      if (y > ptrState->activeMouseY+0.)
        rotateHeadDown(alpha, dx, dy, dz, d, dirx, diry, dirz);
      else if (y < ptrState->activeMouseY-0.)
        rotateHeadUp(alpha, dx, dy, dz, d, dirx, diry, dirz);
      ptrState->activeMouseButton = GLUT_LEFT_BUTTON;
      ptrState->activeMouseX = x;
      ptrState->activeMouseY = y;
    }
    else
    {
      if (abs(x - ptrState->activeMouseX) > abs(y - ptrState->activeMouseY))
      {
        if (x > ptrState->activeMouseX+0.)
          moveLeft(alpha, dx, dy, dz, d, dirx, diry, dirz);
        else if (x < ptrState->activeMouseX-0.)
          moveRight(alpha, dx, dy, dz, d, dirx, diry, dirz);
      }
      else
      {
        if (y < ptrState->activeMouseY-0.)
          moveDown(alpha, dx, dy, dz, d, dirx, diry, dirz);
        else if (y > ptrState->activeMouseY+0.)
          moveUp(alpha, dx, dy, dz, d, dirx, diry, dirz);
      }

      ptrState->activeMouseButton = GLUT_LEFT_BUTTON;
      ptrState->activeMouseX = x;
      ptrState->activeMouseY = y;
    }
  }
  else if (ptrState->activeMouseButton == GLUT_RIGHT_BUTTON)
  {
    double dx = (_view.xeye - _view.xcam);
    double dy = (_view.yeye - _view.ycam);
    double dz = (_view.zeye - _view.zcam);
    double d = sqrt(dx*dx + dy*dy + dz*dz);
    //double alpha = 0.003 + d/dmoy*0.0010;
    double alpha = 0.003 + d/dmoy*0.003;
    dx = dx*alpha; dy = dy*alpha; dz = dz*alpha; d = d*alpha;

    double dirx = _view.dirx;
    double diry = _view.diry;
    double dirz = _view.dirz;
    
    if (ptrState->modifier == GLUT_ACTIVE_CTRL)
    {
      if (x > ptrState->activeMouseX+0.)
        tiltLeft(alpha, dx, dy, dz, d, dirx, diry, dirz);
      else if (x < ptrState->activeMouseX-0.)
        tiltRight(alpha, dx, dy, dz, d, dirx, diry, dirz);
      ptrState->activeMouseButton = GLUT_RIGHT_BUTTON;
      ptrState->activeMouseX = x;
      ptrState->activeMouseY = y;
    }
    else
    {
      if (x > ptrState->activeMouseX+0.)
        strafeLeft(alpha, dx, dy, dz, d, dirx, diry, dirz);
      else if (x < ptrState->activeMouseX-0.)
        strafeRight(alpha, dx, dy, dz, d, dirx, diry, dirz);
      if (y > ptrState->activeMouseY+0.)
        strafeUp(alpha, dx, dy, dz, d, dirx, diry, dirz);
      else if (y < ptrState->activeMouseY-0.)
        strafeDown(alpha, dx, dy, dz, d, dirx, diry, dirz);
      ptrState->activeMouseButton = GLUT_RIGHT_BUTTON;
      ptrState->activeMouseX = x;
      ptrState->activeMouseY = y;
    }
  }
}

//=============================================================================
// Appele quand la souris se balade dans la fenetre sans cliquer (unused)
//=============================================================================
void Data::mousePassiveMotion(E_Int x, E_Int y)
{
  //printf("Mouse passive motion triggered.\n");
  //fdisplay();
}

//=============================================================================
// Called from mouseMotion only
// Select by dragging
//=============================================================================
void Data::mouseDrag(E_Int x, E_Int y)
{
  if (ptrState->render == 1) return; // attend que le render se fasse
  GLint viewport[4];
  GLfloat winX, winY, winZ;
  GLdouble posX, posY, posZ;
  glGetIntegerv(GL_VIEWPORT, viewport);
  winX = (float)x;
  winY = (float)viewport[3] - (float)y;
  glReadPixels(x, int(winY), 1, 1, GL_DEPTH_COMPONENT, GL_FLOAT, &winZ);
  
  if (winZ != 1)
  {
    GLdouble modelview[16];
    GLdouble projection[16];
    glGetDoublev(GL_MODELVIEW_MATRIX, modelview);
    glGetDoublev(GL_PROJECTION_MATRIX, projection);
    gluUnProject(winX, winY, winZ, modelview, projection, viewport, 
                 &posX, &posY, &posZ);

    ptrState->currentMousePosX = posX; ptrState->currentMousePosY = posY;
    ptrState->currentMousePosZ = posZ;

    // coloriage
    E_Int zone, ind, indE, ncon, ret;
    double dist;
    ret = findBlockContaining(posX, posY, posZ,
                              zone, ind, indE, 
                              dist, ncon);
    
    // mise a jour du state
    /*
    Zone* z = _zones[zone];
    if (ret == 1 && (z->active == 1 || ptrState->ghostifyDeactivatedZones == 1))
    {
      ptrState->activePointX = z->x[ind];
      ptrState->activePointY = z->y[ind];
      ptrState->activePointZ = z->z[ind];
      ptrState->activePointZBuf = winZ;
     
      if (zone < _numberOfStructZones)
      {
        StructZone* zz = (StructZone*)z;
        int ni = zz->ni; 
        int nj = zz->nj;
        int k = ind / (ni*nj);
        int j = (ind - k*ni*nj)/ni;
        int i = ind - k*ni*nj - j*ni;
        ptrState->activePointI = i+1;
        ptrState->activePointJ = j+1;
        ptrState->activePointK = k+1;
      }
      else
      {
        ptrState->activePointI = ind; // indice du noeud le plus proche
        ptrState->activePointJ = indE; // indice de l'element contenant P
      }
      for (int n = 0; n < z->nfield; n++)
      {
        double* f = z->f[n];
        ptrState->activePointF[n] = f[ind];
      }
    }
    ptrState->selectedZone = zone+1; 
    */
    // fin mise a jour

    if (ret == 1)
    {
      Zone* z = _zones[zone];
      if (ptrState->activeMouseButton == GLUT_LEFT_BUTTON)
        z->selected = 1;
      else if (ptrState->activeMouseButton == GLUT_RIGHT_BUTTON)
      {
        if (z->active == 1)
        {
          z->active = 0;
          /*
          if (ptrState->deactivatedZones == NULL)
          {
            struct chain_int* ci;
            ci = (struct chain_int*)malloc(sizeof(struct chain_int));
            ci->value = zone+1;
            ci->next = NULL;
            ptrState->deactivatedZones = ci;
          }
          else
          {
            struct chain_int* ci = ptrState->deactivatedZones;
            while (ci->next != NULL) ci = ci->next;
            ci->next = (struct chain_int*)malloc(sizeof(struct chain_int));
            ci = ci->next;
            ci->value = zone+1;
            ci->next = NULL;
          }
          */
          ptrState->insertDeactivatedZones(zone+1);
          //ptrState->printDeactivatedZones();
        }
      }
    }
    ptrState->render = 1;
  }
}
