
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="ASCII" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Connector: Grid connectivity module &#8212; Connector 4.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/classic.css" />
    
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">Connector 4.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Connector: Grid connectivity module</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="connector-grid-connectivity-module">
<h1>Connector: Grid connectivity module</h1>
<section id="preamble">
<h2>Preamble</h2>
<p>Connector module is used to compute connectivity between meshes.
It manipulates arrays (as defined in Converter documentation)
or CGNS/Python trees (pyTrees) as data structures.</p>
<p>This module is part of Cassiopee, a free open-source
pre- and post-processor for CFD simulations.</p>
<p>To use the Connector module with the array interface:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">Connector</span> <span class="k">as</span> <span class="nn">X</span>
</pre></div>
</div>
<p>With the pyTree interface:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">Connector.PyTree</span> <span class="k">as</span> <span class="nn">X</span>
</pre></div>
</div>
<span class="target" id="module-Connector"></span></section>
<section id="list-of-functions">
<h2>List of functions</h2>
<p><strong>&#8211; Multiblock connectivity</strong></p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#Connector.connectMatch" title="Connector.connectMatch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Connector.connectMatch</span></code></a></p></td>
<td><p>Find matching boundaries.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Connector.PyTree.connectMatchPeriodic" title="Connector.PyTree.connectMatchPeriodic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Connector.PyTree.connectMatchPeriodic</span></code></a></p></td>
<td><p>Find periodic matching boundaries.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Connector.PyTree.connectNearMatch" title="Connector.PyTree.connectNearMatch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Connector.PyTree.connectNearMatch</span></code></a></p></td>
<td><p>Find boundaries that matches with a given ratio.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Connector.PyTree.setDegeneratedBC" title="Connector.PyTree.setDegeneratedBC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Connector.PyTree.setDegeneratedBC</span></code></a></p></td>
<td><p>Find degenerated boundaries (lines).</p></td>
</tr>
</tbody>
</table>
<p><strong>&#8211; Overset grid connectivity</strong></p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#Connector.blankCells" title="Connector.blankCells"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Connector.blankCells</span></code></a></p></td>
<td><p>Blank cells in coords by a X-Ray mask defined by the body, within a distance delta.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Connector.blankCellsTetra" title="Connector.blankCellsTetra"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Connector.blankCellsTetra</span></code></a></p></td>
<td><p>Blank cells in coords (by setting the cellN to cellnval) falling inside a Tetra Mesh mask defined by meshT4.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Connector.blankCellsTri" title="Connector.blankCellsTri"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Connector.blankCellsTri</span></code></a></p></td>
<td><p>Blank cells in coords (by setting the cellN to cellnval) falling inside a Triangular surface mesh mask defined by meshT3.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Connector.blankIntersectingCells" title="Connector.blankIntersectingCells"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Connector.blankIntersectingCells</span></code></a></p></td>
<td><p>Blank intersecting cells in a zone.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Connector.setHoleInterpolatedPoints" title="Connector.setHoleInterpolatedPoints"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Connector.setHoleInterpolatedPoints</span></code></a></p></td>
<td><p>Set interpolated points cellN=2 around cellN=0 points.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Connector.optimizeOverlap" title="Connector.optimizeOverlap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Connector.optimizeOverlap</span></code></a></p></td>
<td><p>Optimize the overlap of grids defined by nodes1 and nodes2 centers1 and centers2 define the coordinates of cell centers, modified by the double wall algorithm + cellN variable.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Connector.maximizeBlankedCells" title="Connector.maximizeBlankedCells"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Connector.maximizeBlankedCells</span></code></a></p></td>
<td><p>Maximize the blanked region.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Connector.PyTree.cellN2OversetHoles" title="Connector.PyTree.cellN2OversetHoles"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Connector.PyTree.cellN2OversetHoles</span></code></a></p></td>
<td><p>Create OversetHole nodes from cellN field.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Connector.PyTree.setInterpData" title="Connector.PyTree.setInterpData"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Connector.PyTree.setInterpData</span></code></a></p></td>
<td><p>Compute and store overset interpolation data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Connector.PyTree.setInterpData2" title="Connector.PyTree.setInterpData2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Connector.PyTree.setInterpData2</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Connector.PyTree.getOversetInfo" title="Connector.PyTree.getOversetInfo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Connector.PyTree.getOversetInfo</span></code></a></p></td>
<td><p>Return information on overset connectivities.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Connector.PyTree.extractChimeraInfo" title="Connector.PyTree.extractChimeraInfo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Connector.PyTree.extractChimeraInfo</span></code></a></p></td>
<td><p>Extract interpolated/extrapolated/orphan points as zones.</p></td>
</tr>
</tbody>
</table>
<p><strong>&#8211; Overset grid connectivity for elsA solver</strong></p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#Connector.PyTree.setInterpolations" title="Connector.PyTree.setInterpolations"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Connector.PyTree.setInterpolations</span></code></a></p></td>
<td><p>Compute interpolation data for chimera and for elsA solver.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Connector.PyTree.chimeraInfo" title="Connector.PyTree.chimeraInfo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Connector.PyTree.chimeraInfo</span></code></a></p></td>
<td><p>Extract Overset information when computed with setInterpolations.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="contents">
<h2>Contents</h2>
<section id="multiblock-connectivity">
<h3>Multiblock connectivity</h3>
<dl class="py function">
<dt class="sig sig-object py" id="Connector.connectMatch">
<span class="sig-prename descclassname"><span class="pre">Connector.</span></span><span class="sig-name descname"><span class="pre">connectMatch</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Detect and set all matching windows, even partially.</p>
<p><em>Using the array interface:</em></p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">res</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">connectMatch</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">sameZone</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1.e-6</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Detect and set all matching windows between two structured arrays a1 and a2.
Return the subrange of indices of abutting windows and an index transformation from a1 to a2.
If the CFD problem is 2D, then dim must be set to 2.
Parameter sameZone must be set to 1 if a1 and a2 define the same zone.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>a1</strong><strong>,</strong><strong>a2</strong> (<em>arrays</em>) &#8211; Input data</p>
</dd>
</dl>
<p><em>Using the PyTree interface:</em></p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">connectMatch</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1.e-6</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>Detect and set all matching windows in a zone node, a list of zone nodes or a complete pyTree.
Set automatically the Transform node corresponding to the transformation from matching block 1 to block 2.
If the CFD problem is 2D, then dim must be set to 2.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>t</strong> (<em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em>) &#8211; input data</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>identical to input</p>
</dd>
</dl>
<p>Exists also as parallel distributed version (X.Mpi.connectMatch).</p>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/connectMatch.py">Detect matching boundaries of a mesh (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - connectMatch (array) -</span>
<span class="kn">import</span> <span class="nn">Generator</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Connector</span> <span class="k">as</span> <span class="nn">X</span>
<span class="kn">import</span> <span class="nn">Geom</span> <span class="k">as</span> <span class="nn">D</span>
<span class="kn">import</span> <span class="nn">Transform</span> <span class="k">as</span> <span class="nn">T</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>
<span class="c1"># 3D raccord i = 1 partiel profil NACA</span>
<span class="n">msh</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">naca</span><span class="p">(</span><span class="mf">12.</span><span class="p">,</span> <span class="mi">5001</span><span class="p">)</span>
<span class="n">msh2</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">line</span><span class="p">((</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),(</span><span class="mf">2.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),</span><span class="mi">5001</span><span class="p">);</span> <span class="n">msh</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">msh</span><span class="p">,</span> <span class="n">msh2</span><span class="p">)</span>
<span class="n">msh2</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">line</span><span class="p">((</span><span class="mf">2.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),</span><span class="mi">5001</span><span class="p">);</span> <span class="n">msh</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">msh2</span><span class="p">,</span> <span class="n">msh</span><span class="p">)</span>
<span class="n">Ni</span> <span class="o">=</span> <span class="mi">300</span><span class="p">;</span> <span class="n">Nj</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">distrib</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">Ni</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mf">0.5</span><span class="o">/</span><span class="p">(</span><span class="n">Nj</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">Ni</span><span class="p">,</span><span class="n">Nj</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="n">naca</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">hyper2D</span><span class="p">(</span><span class="n">msh</span><span class="p">,</span> <span class="n">distrib</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">)</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">connectMatch</span><span class="p">(</span><span class="n">naca</span><span class="p">,</span><span class="n">naca</span><span class="p">,</span><span class="n">sameZone</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">([</span><span class="n">naca</span><span class="p">],</span><span class="s2">&quot;out.plt&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/connectMatchPT.py">Add 1-to-1 abutting connectivity in a pyTree (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - connectMatch (pyTree) -</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Connector.PyTree</span> <span class="k">as</span> <span class="nn">X</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>

<span class="n">a1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">),</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span> <span class="n">a1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cart1&#39;</span>
<span class="n">a2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">),</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span> <span class="n">a2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cart2&#39;</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Base&#39;</span><span class="p">,</span><span class="n">a1</span><span class="p">,</span><span class="n">a2</span><span class="p">])</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">connectMatch</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Connector.PyTree.connectMatchPeriodic">
<span class="sig-prename descclassname"><span class="pre">Connector.PyTree.</span></span><span class="sig-name descname"><span class="pre">connectMatchPeriodic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotationCenter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0.,</span> <span class="pre">0.,</span> <span class="pre">0.]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotationAngle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0.,</span> <span class="pre">0.,</span> <span class="pre">0.]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">translation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0.,</span> <span class="pre">0.,</span> <span class="pre">0.]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.e-6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unitAngle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Detect and set all periodic matching borders, even partially, in a zone node, a list of zone nodes, a base, or a full pyTree.
Periodicity can be defined either by rotation or translation or by a composition of rotation and translation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>t</strong> (<em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em>) &#8211; input data</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>identical to input</p>
</dd>
</dl>
<p>Set automatically the Transform node corresponding to the transformation from matching block 1 to block 2, and the &#8216;GridConnectivityProperty/Periodic&#8217; for periodic matching BCs.</p>
<p>If the CFD problem is 2D, then dim must be set to 2.</p>
<p>For periodicity by rotation, the rotation angle units can be specified by argument unitAngle, which can be &#8216;Degree&#8217;,&#8217;Radian&#8217;,None.</p>
<p>If unitAngle=None or &#8216;Degree&#8217;: parameter rotationAngle is assumed to be defined in degrees.</p>
<p>If unitAngle=&#8217;Radian&#8217;: parameter rotationAngle is assumed in radians.</p>
<p>Exists also as parallel distributed version (X.Mpi.connectMatchPeriodic).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>if the mesh is periodic in rotation and in translation separately (i.e. connecting with some blocks in rotation, and some other blocks in translation), the function must be applied twice.</p></li>
<li><p>Since <em>Cassiopee2.6</em>: &#8216;RotationAngle&#8217; node in &#8216;Periodic&#8217; node is always defined in Radians. A DimensionalUnits child node is also defined.</p></li>
</ul>
</div>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/connectMatchPeriodicPT.py">Add periodic  1-to-1 abutting grid connectivity in a pyTree (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - connectMatch (pyTree) -</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Connector.PyTree</span> <span class="k">as</span> <span class="nn">X</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cylinder</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">90.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">,</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">11</span><span class="p">))</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Base&#39;</span><span class="p">,</span><span class="n">a</span><span class="p">])</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">connectMatchPeriodic</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">rotationCenter</span><span class="o">=</span><span class="p">[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],</span>
                           <span class="n">translation</span><span class="o">=</span><span class="p">[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">5.</span><span class="p">])</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">connectMatchPeriodic</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">rotationCenter</span><span class="o">=</span><span class="p">[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],</span>
                           <span class="n">rotationAngle</span><span class="o">=</span><span class="p">[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">90.</span><span class="p">])</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Connector.PyTree.connectNearMatch">
<span class="sig-prename descclassname"><span class="pre">Connector.PyTree.</span></span><span class="sig-name descname"><span class="pre">connectNearMatch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.e-6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Detect and set all near-matching windows, even partially in a zone node, a list of zone nodes or a complete pyTree.
A &#8216;UserDefinedData&#8217; node is set, with the PointRangeDonor, the Transform and NMRatio nodes providing information for the opposite zone.
.. warning:: connectMatch must be applied first if matching windows exist.</p>
<p>Parameter ratio defines the ratio between near-matching windows and can be an integer (e.g. 2) or a list of 3 integers (e.g. [1,2,1]), specifying
the nearmatching direction to test (less CPU-consuming).
If the CFD problem is 2D, then dim must be set to 2.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>t</strong> (<em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em>) &#8211; input data</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>identical to input</p>
</dd>
</dl>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/connectNearMatchPT.py">Add n-to-m abutting grid connectivity in a pyTree (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - connectNearMatch (pyTree) -</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Connector.PyTree</span> <span class="k">as</span> <span class="nn">X</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Transform.PyTree</span> <span class="k">as</span> <span class="nn">T</span>

<span class="n">a1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">),</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span> <span class="n">a1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cart1&#39;</span>
<span class="n">a2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">),</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span> <span class="n">a2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cart2&#39;</span>
<span class="n">a2</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">oneovern</span><span class="p">(</span><span class="n">a2</span><span class="p">,(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Base&#39;</span><span class="p">,</span><span class="n">a1</span><span class="p">,</span><span class="n">a2</span><span class="p">])</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">connectNearMatch</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Connector.PyTree.setDegeneratedBC">
<span class="sig-prename descclassname"><span class="pre">Connector.PyTree.</span></span><span class="sig-name descname"><span class="pre">setDegeneratedBC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.e-10</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Detect all degenerated lines in 3D zones and define a BC as a &#8216;BCDegenerateLine&#8217; BC type. For 2D zones, &#8216;BCDegeneratePoint&#8217;
type is defined.
If the problem is 2D according to (i,j), then parameter &#8216;dim&#8217; must be set to 2.
Parameter &#8216;tol&#8217; defines a distance below which a window is assumed degenerated.</p>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/setDegeneratedBCPT.py">Add degenerated line as BCs in a pyTree (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - setDegeneratedBC (pyTree) -</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Connector.PyTree</span> <span class="k">as</span> <span class="nn">X</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cylinder</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">360.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">21</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">21</span><span class="p">))</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Base&#39;</span><span class="p">,</span><span class="n">a</span><span class="p">])</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">setDegeneratedBC</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;out.cgns&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<hr class="docutils" />
<section id="overset-connectivity">
<h3>Overset connectivity</h3>
<dl class="py function">
<dt class="sig sig-object py" id="Connector.blankCells">
<span class="sig-prename descclassname"><span class="pre">Connector.</span></span><span class="sig-name descname"><span class="pre">blankCells</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Blank cells using X-Ray method.</p>
<p><em>Using the array interface:</em></p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cellns</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">blankCells</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">cellns</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">blankingType</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">1.e-10</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">masknot</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1.e-8</span><span class="p">)</span>
</pre></div>
</div>
<p>Blank the cells of a list of grids defined by coords (located at nodes).
The X-Ray mask is defined by bodies, which is a list of arrays.
Cellnaturefield defined in cellns is modified (0: blanked points, 1: otherwise).
Some parameters can be specified: blankingType, delta, masknot, tol. Their meanings are described in the table below:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Parameter value</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>blankingType=0</p></td>
<td><p>blank nodes inside bodies (node_in).</p></td>
</tr>
<tr class="row-odd"><td><p>blankingType=2</p></td>
<td><p>blank cell centers inside bodies (center_in).</p></td>
</tr>
<tr class="row-even"><td><p>blankingType=1</p></td>
<td><p>blank cell centers intersecting with body (cell_intersect).</p></td>
</tr>
<tr class="row-odd"><td><p>blankingType=-2</p></td>
<td><p>blank cell centers using an optimized cell intersection (cell_intersect_opt)
and interpolation depth=2 (blanking region may be reduced where blanking point
can be interpolated).</p></td>
</tr>
<tr class="row-even"><td><p>blankingType=-1</p></td>
<td><p>blank cell centers using an optimized cell intersection (cell_intersect_opt)
and interpolation depth=1.</p></td>
</tr>
<tr class="row-odd"><td><p>delta=0.</p></td>
<td><p>cells are blanked in the body</p></td>
</tr>
<tr class="row-even"><td><p>delta greater than 0.</p></td>
<td><p>the maximum distance to body, in which cells are blanked</p></td>
</tr>
<tr class="row-odd"><td><p>masknot=0</p></td>
<td><p>Classical blanking applied</p></td>
</tr>
<tr class="row-even"><td><p>masknot=1</p></td>
<td><p>Inverted blanking applied: cells out of the body are blanked</p></td>
</tr>
<tr class="row-odd"><td><p>dim=3</p></td>
<td><p>body described by a surface and blanks 3D cells.</p></td>
</tr>
<tr class="row-even"><td><p>dim=2</p></td>
<td><p>body blanks 2D or 1D zones.</p></td>
</tr>
<tr class="row-odd"><td><p>tol=1.e-8 (default)</p></td>
<td><p>tolerance for the multiple definition of the body.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>in case of blankingType=0, location of cellns and coords must be identical.</p>
</div>
</div></blockquote>
<dl>
<dt><em>Using the pyTree interface:</em></dt><dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">blankCells</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">bodies</span><span class="p">,</span> <span class="n">BM</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">blankingType</span><span class="o">=</span><span class="s1">&#39;cell_intersect&#39;</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">1.e-10</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1.e-8</span><span class="p">,</span> <span class="n">XRaydim1</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">XRaydim2</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>blankCells</strong> function sets the cellN to 0 to blanked nodes or cell centers of both structured and unstructured grids.</p>
<p>The location of the cellN field depends on the <em>blankingType</em> parameter: if &#8216;node_in&#8217; is used, nodes are blanked, else centers are blanked.</p>
<p>The mesh to be blanked is defined by a pyTree t, where each basis defines a Chimera component. The list of bodies blanking the grids is defined in bodies.</p>
<p>Each element of the list bodies is a set of CGNS/Python zones defining a closed and watertight surface.</p>
<p>The blanking matrix BM is a numpy array of size nbases x nbodies.</p>
<p>BM(i,j)=1 means that ith basis is blanked by jth body.</p>
<p>BM(i,j)=0 means no blanking, and BM(i,j)=-1 means that inverted hole-cutting is performed.</p>
<p>blankingType can be &#8216;cell_intersect&#8217;, &#8216;cell_intersect_opt&#8217;, &#8216;center_in&#8217; or &#8216;node_in&#8217;. Parameter depth is only meaningfull for &#8216;cell_intersect_opt&#8217;.</p>
<p>XRaydim1 and XRaydim2 are the dimensions of the X-Ray hole-cutting in the x and y directions in 3D.</p>
<p>If the variable &#8216;cellN&#8217; does not exist in the input pyTree, it is initialized to 1, located at &#8216;nodes&#8217; if &#8216;node_in&#8217; is set, and at centers in other cases.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>&#8216;cell_intersect_opt&#8217; can be CPU time-consuming when delta&gt;0.</p>
</div>
</dd>
</dl>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/blankCells.py">Blank cells (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - blankCells (array) -</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Connector</span> <span class="k">as</span> <span class="nn">X</span>
<span class="kn">import</span> <span class="nn">Generator</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Geom</span> <span class="k">as</span> <span class="nn">D</span>

<span class="n">surf</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">sphere</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="n">surf</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2Tetra</span><span class="p">(</span><span class="n">surf</span><span class="p">)</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span><span class="o">-</span><span class="mf">1.</span><span class="p">),(</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">))</span>
<span class="n">ca</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;cellN&#39;</span><span class="p">,</span><span class="mi">19</span><span class="p">,</span><span class="mi">19</span><span class="p">,</span><span class="mi">19</span><span class="p">)</span>
<span class="n">ca</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">initVars</span><span class="p">(</span><span class="n">ca</span><span class="p">,</span> <span class="s1">&#39;cellN&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
<span class="n">celln</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">blankCells</span><span class="p">([</span><span class="n">a</span><span class="p">],</span> <span class="p">[</span><span class="n">ca</span><span class="p">],</span> <span class="p">[</span><span class="n">surf</span><span class="p">],</span> <span class="n">blankingType</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">node2Center</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">celln</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addVars</span><span class="p">([[</span><span class="n">a</span><span class="p">],</span> <span class="n">celln</span><span class="p">])</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">(</span><span class="n">celln</span><span class="p">,</span> <span class="s1">&#39;out.plt&#39;</span><span class="p">)</span>

<span class="c1"># in place-modifies cellN</span>
<span class="n">surf</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">sphere</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="n">surf</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2Tetra</span><span class="p">(</span><span class="n">surf</span><span class="p">)</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span><span class="o">-</span><span class="mf">1.</span><span class="p">),(</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">))</span>
<span class="n">ca</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;cellN&#39;</span><span class="p">,</span><span class="mi">19</span><span class="p">,</span><span class="mi">19</span><span class="p">,</span><span class="mi">19</span><span class="p">)</span>
<span class="n">ca</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">initVars</span><span class="p">(</span><span class="n">ca</span><span class="p">,</span> <span class="s1">&#39;cellN&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
<span class="n">X</span><span class="o">.</span><span class="n">_blankCells</span><span class="p">([</span><span class="n">a</span><span class="p">],</span> <span class="p">[</span><span class="n">ca</span><span class="p">],</span> <span class="p">[</span><span class="n">surf</span><span class="p">],</span> <span class="n">blankingType</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">node2Center</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">celln</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addVars</span><span class="p">([[</span><span class="n">a</span><span class="p">],</span> <span class="n">celln</span><span class="p">])</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">(</span><span class="n">celln</span><span class="p">,</span> <span class="s1">&#39;out.plt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/blankCellsPT.py">Blank cells (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - blankCells (pyTree) -</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Connector.PyTree</span> <span class="k">as</span> <span class="nn">X</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Geom.PyTree</span> <span class="k">as</span> <span class="nn">D</span>

<span class="n">surf</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">sphere</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span><span class="o">-</span><span class="mf">1.</span><span class="p">),(</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">))</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Cart&#39;</span><span class="p">,</span><span class="n">a</span><span class="p">])</span>
<span class="n">C</span><span class="o">.</span><span class="n">_initVars</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;centers:cellN&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>

<span class="n">bodies</span> <span class="o">=</span> <span class="p">[[</span><span class="n">surf</span><span class="p">]]</span>
<span class="c1"># Matrice de masquage (arbre d&#39;assemblage)</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="n">BM</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="p">[</span> <span class="mi">1</span><span class="p">]</span> <span class="p">]</span> <span class="p">)</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">blankCells</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">bodies</span><span class="p">,</span> <span class="n">BM</span><span class="p">,</span> <span class="n">blankingType</span><span class="o">=</span><span class="s1">&#39;cell_intersect&#39;</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Connector.blankCellsTetra">
<span class="sig-prename descclassname"><span class="pre">Connector.</span></span><span class="sig-name descname"><span class="pre">blankCellsTetra</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p><em>Using the array interface:</em></p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cellns</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">blankCellsTetra</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">cellns</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">blankingType</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1.e-12</span><span class="p">)</span>
</pre></div>
</div>
<p>Blanks the input grids nodes or cells (depending on the <em>blankingType</em> value) that fall inside a volume body mask.
The blanking is achieved by setting the Cellnaturefield to <em>cellnval</em> (0 by default) in <em>cellns</em>.</p>
<p>The input grids are defined by coords located at nodes as a list of arrays. The body mask is defined by sets of tetrahedra in any orientation, as a list of arrays.</p>
<p>If the <em>blankingMode</em> is set to 1 (overwrite mode), Cellnaturefield is reset to 1 for any node/cell outside the body mask.
Hence the value of 1 is forbidden for cellnval upon entry (it will be replaced by 0).</p>
<p>The parameters meanings and values are described in the table below:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Parameter value</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>blankingType=0</p></td>
<td><p>blanks the nodes falling inside the body masks (node_in).</p></td>
</tr>
<tr class="row-odd"><td><p>blankingType=2</p></td>
<td><p>blanks the cells having their center falling inside the body masks (center_in).</p></td>
</tr>
<tr class="row-even"><td><p>blankingType=1</p></td>
<td><p>blanks the cells that intersect or fall inside the body masks (cell_intersect).</p></td>
</tr>
<tr class="row-odd"><td><p>tol=1.e-12</p></td>
<td><p>tolerance for detecting intersections (NOT USED CURRENTLY).</p></td>
</tr>
<tr class="row-even"><td><p>cellnval=0 (default)</p></td>
<td><p>value used for flagging as blanked.</p></td>
</tr>
<tr class="row-odd"><td><p>blankingMode=0 (default)</p></td>
<td><p>Appending mode: cellns is only modified for nodes/cells falling inside the body
mask by setting the value in cellns to cellnval.</p></td>
</tr>
<tr class="row-even"><td><p>blankingMode=1</p></td>
<td><p>Overwriting mode: cellns is modified for both nodes/cells falling inside
(set to cellnval) and outside (set to 1) the body mask.</p></td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>in case of blankingType=0, location of cellns and coords must be identical.</p>
</div>
</div></blockquote>
<p><em>Using the pyTree interface:</em></p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">blankCellsTetra</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">bodies</span><span class="p">,</span> <span class="n">BM</span><span class="p">,</span> <span class="n">blankingType</span><span class="o">=</span><span class="s1">&#39;node_in&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1.e-12</span><span class="p">,</span> <span class="n">cellnval</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Blanks the input grids nodes or cells (depending on the <em>blankingType</em> value) that fall inside a volume body mask.</p>
<p>The blanking is achieved by setting the Cellnaturefield to <em>cellnval</em> (0 by default) in <em>cellns</em>.</p>
<p>The mesh to be blanked is defined by a pyTree t, where each basis defines a Chimera component. The list of bodies blanking the grids is defined in bodies.</p>
<p>Each element of the list bodies is a set of CGNS/Python zones defining a tetrahedra mesh.</p>
<p>The blanking matrix BM is a numpy array of size nbases x nbodies.</p>
<p>BM(i,j)=1 means that ith basis is blanked by jth body.</p>
<p>BM(i,j)=0 means no blanking, and BM(i,j)=-1 means that inverted hole-cutting is performed.</p>
<p>blankingType can be &#8216;cell_intersect&#8217;, &#8216;center_in&#8217; or &#8216;node_in&#8217;.</p>
<p>If the variable &#8216;cellN&#8217; does not exist in the input pyTree, it is initialized to 1, located at &#8216;nodes&#8217; if &#8216;node_in&#8217; is set, and at centers in other cases.</p>
<p>If the <em>overwrite</em> is set to 1 (overwrite mode), Cellnaturefield is reset to 1 for any node/cell outside the body mask.</p>
<p>Hence the value of 1 is forbidden for cellnval upon entry (it will be replaced by 0).</p>
</div></blockquote>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/blankCellsTetra.py">Blank cells with a tetra mesh (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - blankCellsTetra (array) - &#39;NODE IN&#39;</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Connector</span> <span class="k">as</span> <span class="nn">X</span>
<span class="kn">import</span> <span class="nn">Generator</span> <span class="k">as</span> <span class="nn">G</span>

<span class="c1"># Tet mask</span>
<span class="n">mT4</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.2</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">mT4</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2Tetra</span><span class="p">(</span><span class="n">mT4</span><span class="p">)</span>
<span class="c1">#C.convertArrays2File([mT4], &#39;maskT4.plt&#39;, &#39;bin_tp&#39;)</span>

<span class="c1"># Mesh to blank</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="o">-</span><span class="mf">5.</span><span class="p">,</span><span class="o">-</span><span class="mf">5.</span><span class="p">,</span><span class="o">-</span><span class="mf">5.</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">),</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
<span class="c1">#C.convertArrays2File([a], &#39;bgm.plt&#39;)</span>

<span class="n">ca</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;cellN&#39;</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
<span class="n">ca</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">initVars</span><span class="p">(</span><span class="n">ca</span><span class="p">,</span> <span class="s1">&#39;cellN&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
<span class="c1">#C.convertArrays2File([ca], &#39;ca.plt&#39;)</span>

<span class="n">celln</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">blankCellsTetra</span><span class="p">([</span><span class="n">a</span><span class="p">],</span> <span class="p">[</span><span class="n">ca</span><span class="p">],</span> <span class="p">[</span><span class="n">mT4</span><span class="p">],</span> <span class="n">blankingType</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1.e-12</span><span class="p">)</span>

<span class="n">celln</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addVars</span><span class="p">([[</span><span class="n">a</span><span class="p">],</span> <span class="n">celln</span><span class="p">])</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">(</span><span class="n">celln</span><span class="p">,</span> <span class="s1">&#39;out.plt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/blankCellsTetraPT.py">Blank cells with a tetra mesh (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - blankCellsTetra (pyTree) - &#39;NODE IN&#39;</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Connector.PyTree</span> <span class="k">as</span> <span class="nn">X</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>

<span class="c1"># Tet mask</span>
<span class="n">mT4</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.2</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">mT4</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2Tetra</span><span class="p">(</span><span class="n">mT4</span><span class="p">)</span>

<span class="c1"># Mesh to blank</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="o">-</span><span class="mf">5.</span><span class="p">,</span><span class="o">-</span><span class="mf">5.</span><span class="p">,</span><span class="o">-</span><span class="mf">5.</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">),</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Cart&#39;</span><span class="p">,</span><span class="n">a</span><span class="p">])</span>
<span class="n">C</span><span class="o">.</span><span class="n">_initVars</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;centers:cellN&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>

<span class="n">masks</span> <span class="o">=</span> <span class="p">[[</span><span class="n">mT4</span><span class="p">]]</span>
<span class="c1"># Matrice de masquage (arbre d&#39;assemblage)</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="n">BM</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]])</span>

<span class="n">t1</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">blankCellsTetra</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">masks</span><span class="p">,</span> <span class="n">BM</span><span class="p">,</span> <span class="n">blankingType</span><span class="o">=</span><span class="s1">&#39;node_in&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1.e-12</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>

<span class="n">t2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2Tetra</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">blankCellsTetra</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">masks</span><span class="p">,</span> <span class="n">BM</span><span class="p">,</span> <span class="n">blankingType</span><span class="o">=</span><span class="s1">&#39;node_in&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1.e-12</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;out2.cgns&#39;</span><span class="p">)</span>

<span class="n">t3</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">t3</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">blankCellsTetra</span><span class="p">(</span><span class="n">t3</span><span class="p">,</span> <span class="n">masks</span><span class="p">,</span> <span class="n">BM</span><span class="p">,</span> <span class="n">blankingType</span><span class="o">=</span><span class="s1">&#39;node_in&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1.e-12</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t3</span><span class="p">,</span> <span class="s1">&#39;out3.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Connector.blankCellsTri">
<span class="sig-prename descclassname"><span class="pre">Connector.</span></span><span class="sig-name descname"><span class="pre">blankCellsTri</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p><em>Using the array interface:</em></p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cellns</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">blankCellsTri</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">cellns</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">blankingType</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1.e-12</span><span class="p">,</span> <span class="n">cellnval</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">blankingMode</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Blanks the input grids nodes or cells (depending on the <em>blankingType</em> value) that fall inside a surfacic body mask.</p>
<p>The blanking is achieved by setting the Cellnaturefield to <em>cellnval</em> (0 by default) in <em>cellns</em>.</p>
<p>The input grids are defined by coords located at nodes as a list of arrays. The body mask is defined by triangular surface meshes in any orientation, as a list of arrays.</p>
<p>If the <em>blankingMode</em> is set to 1 (overwrite mode), Cellnaturefield is reset to 1 for any node/cell outside the body mask.
Hence the value of 1 is forbidden for cellnval upon entry (it will be replaced by 0).</p>
<p>The parameters meanings and values are described in the table below:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Parameter value</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>blankingType=0</p></td>
<td><p>blanks the nodes falling inside the body masks (node_in).</p></td>
</tr>
<tr class="row-odd"><td><p>blankingType=2</p></td>
<td><p>blanks the cells having their center falling inside the body masks (center_in).</p></td>
</tr>
<tr class="row-even"><td><p>blankingType=1</p></td>
<td><p>blanks the cells that intersect or fall inside the body masks (cell_intersect).</p></td>
</tr>
<tr class="row-odd"><td><p>tol=1.e-12 (default)</p></td>
<td><p>tolerance for detecting intersections (NOT USED CURRENTLY).</p></td>
</tr>
<tr class="row-even"><td><p>cellnval=0 (default)</p></td>
<td><p>value used for flagging as blanked.</p></td>
</tr>
<tr class="row-odd"><td><p>blankingMode=0 (default)</p></td>
<td><p>Appending mode: cellns is only modified for nodes/cells falling inside the body
mask by setting the value in cellns to cellnval.</p></td>
</tr>
<tr class="row-even"><td><p>blankingMode=1</p></td>
<td><p>Overwriting mode: cellns is modified for both nodes/cells falling inside
(set to cellnval) and outside (set to 1) the body mask.</p></td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>in case of blankingType=0, location of cellns and coords must be identical.</p>
</div>
</div></blockquote>
<p><em>Using the pyTree interface:</em></p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">blankCellsTri</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">bodies</span><span class="p">,</span> <span class="n">BM</span><span class="p">,</span> <span class="n">blankingType</span><span class="o">=</span><span class="s1">&#39;node_in&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1.e-12</span><span class="p">,</span> <span class="n">cellnval</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Blanks the input grids nodes or cells (depending on the <em>blankingType</em> value) that fall inside a volume body mask.</p>
<p>The blanking is achieved by setting the Cellnaturefield to <em>cellnval</em> (0 by default) in <em>cellns</em>.</p>
<p>The mesh to be blanked is defined by a pyTree t, where each basis defines a Chimera component. The list of bodies blanking the grids is defined in bodies.</p>
<p>Each element of the list bodies is a set of CGNS/Python zones defining a triangular watertight closed surface.</p>
<p>The blanking matrix BM is a numpy array of size nbases x nbodies.</p>
<p>BM(i,j)=1 means that ith basis is blanked by jth body.</p>
<p>BM(i,j)=0 means no blanking, and BM(i,j)=-1 means that inverted hole-cutting is performed.</p>
<p>blankingType can be &#8216;cell_intersect&#8217;, &#8216;center_in&#8217; or &#8216;node_in&#8217;.</p>
<p>If the variable &#8216;cellN&#8217; does not exist in the input pyTree, it is initialized to 1, located at &#8216;nodes&#8217; if &#8216;node_in&#8217; is set, and at centers in other cases.</p>
<p>If the <em>overwrite</em> is set to 1 (overwrite mode), Cellnaturefield is reset to 1 for any node/cell outside the body mask.</p>
<p>Hence the value of 1 is forbidden for cellnval upon entry (it will be replaced by 0).</p>
</div></blockquote>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/blankCellsTri.py">Blank cells with a triangular surface mask (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - blankCellsTri (array) - &#39;NODE IN&#39;</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Connector</span> <span class="k">as</span> <span class="nn">X</span>
<span class="kn">import</span> <span class="nn">Generator</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Post</span> <span class="k">as</span> <span class="nn">P</span>

<span class="c1"># Tri mask</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.2</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">exteriorFaces</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

<span class="c1"># Mesh to blank</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="o">-</span><span class="mf">5.</span><span class="p">,</span><span class="o">-</span><span class="mf">5.</span><span class="p">,</span><span class="o">-</span><span class="mf">5.</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">),</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
<span class="c1"># celln init</span>
<span class="n">ca</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;cellN&#39;</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
<span class="n">ca</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">initVars</span><span class="p">(</span><span class="n">ca</span><span class="p">,</span> <span class="s1">&#39;cellN&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
<span class="c1"># Blanking</span>
<span class="n">celln</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">blankCellsTri</span><span class="p">([</span><span class="n">a</span><span class="p">],</span> <span class="p">[</span><span class="n">ca</span><span class="p">],</span> <span class="n">m</span><span class="p">,</span> <span class="n">blankingType</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1.e-12</span><span class="p">)</span>
<span class="n">celln</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addVars</span><span class="p">([[</span><span class="n">a</span><span class="p">],</span> <span class="n">celln</span><span class="p">])</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">(</span><span class="n">celln</span><span class="p">,</span> <span class="s1">&#39;out0.plt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/blankCellsTriPT.py">Blank cells with a triangular surface mask (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - blankCellsTri (pyTree) - &#39;NODE IN&#39;</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Connector.PyTree</span> <span class="k">as</span> <span class="nn">X</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Post.PyTree</span> <span class="k">as</span> <span class="nn">P</span>

<span class="c1"># Tet mask</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.2</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">exteriorFaces</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

<span class="c1"># Mesh to blank</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="o">-</span><span class="mf">5.</span><span class="p">,</span><span class="o">-</span><span class="mf">5.</span><span class="p">,</span><span class="o">-</span><span class="mf">5.</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">),</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Cart&#39;</span><span class="p">,</span><span class="n">a</span><span class="p">])</span>
<span class="n">C</span><span class="o">.</span><span class="n">_initVars</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;centers:cellN&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>

<span class="n">masks</span> <span class="o">=</span> <span class="p">[[</span><span class="n">m</span><span class="p">]]</span>
<span class="c1"># Matrice de masquage (arbre d&#39;assemblage)</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="n">BM</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]])</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">blankCellsTri</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">masks</span><span class="p">,</span> <span class="n">BM</span><span class="p">,</span> <span class="n">blankingType</span><span class="o">=</span><span class="s1">&#39;node_in&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1.e-12</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Connector.setHoleInterpolatedPoints">
<span class="sig-prename descclassname"><span class="pre">Connector.</span></span><span class="sig-name descname"><span class="pre">setHoleInterpolatedPoints</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p><em>Using the array interface:</em></p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">setHoleInterpolatedPoints</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;centers&#39;</span><span class="p">,</span> <span class="n">cellNName</span><span class="o">=</span><span class="s1">&#39;cellN&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Compute the fringe of interpolated points around a set of blanked points in a mesh a.
Parameter depth is the number of layers of interpolated points to be set.
If depth &gt; 0 the fringe of interpolated points is set outside the blanked zones,
whereas if depth &lt; 0, the depth layers of blanked points are marked as to be interpolated.
If dir=0, uses a directional stencil of depth points, if dir=1, uses a star shape stencil,
if dir=2, uses a diamond stencil, if dir=3, uses an octahedron stencil.
Blanked points are identified by the variable &#8216;cellN&#8217;; &#8216;cellN&#8217; is set to 2 for the fringe of interpolated points.
If cellN is located at cell centers, set loc parameter to &#8216;centers&#8217;, else loc=&#8217;nodes&#8217;.</p>
</div></blockquote>
<p><em>Using the pyTree interface:</em></p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">setHoleInterpolatedPoints</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;centers&#39;</span><span class="p">,</span> <span class="n">cellNName</span><span class="o">=</span><span class="s1">&#39;cellN&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Compute the fringe of interpolated points around a set of blanked points in a pyTree t.
Parameter depth is the number of layers of interpolated points that are built; if depth &gt; 0 the fringe of interpolated points is outside the blanked zones, and if depth &lt; 0,
it is built towards the inside.
If dir=0, uses a directional stencil of depth points, if dir=1, uses a star shape stencil,
if dir=2, uses a diamond stencil, if dir=3, uses an octahedron stencil.
Blanked points are identified by the variable &#8216;cellN&#8217; located at mesh nodes or centers. &#8216;cellN&#8217; is set to 2 for the fringe of interpolated points.</p>
</div></blockquote>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/setHoleInterpolatedPts.py">Set the fringe of interpolated points near blanked points (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - setHoleInterpolatedPts (array) -</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Connector</span> <span class="k">as</span> <span class="nn">X</span>
<span class="kn">import</span> <span class="nn">Generator</span> <span class="k">as</span> <span class="nn">G</span>

<span class="k">def</span> <span class="nf">sphere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="o">+</span><span class="n">z</span><span class="o">*</span><span class="n">z</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="o">**</span><span class="mi">2</span> <span class="p">:</span> <span class="k">return</span> <span class="mf">0.</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="mf">1.</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span><span class="o">-</span><span class="mf">1.</span><span class="p">),(</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">))</span>
<span class="n">celln</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">node2Center</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">celln</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">initVars</span><span class="p">(</span><span class="n">celln</span><span class="p">,</span> <span class="s1">&#39;cellN&#39;</span><span class="p">,</span> <span class="n">sphere</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">])</span>
<span class="n">celln</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">setHoleInterpolatedPoints</span><span class="p">(</span><span class="n">celln</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">([</span><span class="n">celln</span><span class="p">],</span> <span class="s1">&#39;out.plt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/setHoleInterpolatedPtsPT.py">Set the fringe of interpolated points near the blanked points (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - setHoleInterpolatedPoints (pyTree) -</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Connector.PyTree</span> <span class="k">as</span> <span class="nn">X</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>

<span class="n">N</span> <span class="o">=</span> <span class="mi">101</span>
<span class="n">h</span> <span class="o">=</span> <span class="mf">2.</span><span class="o">/</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span><span class="o">-</span><span class="mf">1.</span><span class="p">),(</span><span class="n">h</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">h</span><span class="p">),</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">))</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Cart&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">])</span>
<span class="n">C</span><span class="o">.</span><span class="n">_initVars</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="s1">&#39;{centers:cellN}=(1.-({centers:CoordinateX}*{centers:CoordinateX}+{centers:CoordinateY}*{centers:CoordinateY}+{centers:CoordinateZ}*{centers:CoordinateZ}&lt;0.25))&#39;</span><span class="p">)</span>

<span class="n">X</span><span class="o">.</span><span class="n">_setHoleInterpolatedPoints</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Connector.optimizeOverlap">
<span class="sig-prename descclassname"><span class="pre">Connector.</span></span><span class="sig-name descname"><span class="pre">optimizeOverlap</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p><em>Using the array interface:</em></p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cellns</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">optimizeOverlap</span><span class="p">(</span><span class="n">nodes1</span><span class="p">,</span> <span class="n">centers1</span><span class="p">,</span> <span class="n">nodes2</span><span class="p">,</span> <span class="n">centers2</span><span class="p">,</span> <span class="n">prio1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">prio2</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Optimize the overlap between two zones defined by nodes1 and nodes2, centers1 and centers2 correspond to the mesh located at centers and the field &#8216;cellN&#8217;.
The field &#8216;cellN&#8217; located at centers is set to 2 for interpolable points.
Priorities can be defined for zones: prio1=0 means that the priority of zone 1 is high.
If two zones have the same priority, then the cell volume criterion is used to set the cellN to 2 for one of the overlapping cells, the other not being modified.
If the priorities are not specified, the cell volume criterion is applied also:</p>
</div></blockquote>
<p><em>Using the pyTree interface:</em></p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">optimizeOverlap</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">double_wall</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">priorities</span><span class="o">=</span><span class="p">[],</span> <span class="n">planarTol</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>
</pre></div>
</div>
<p>Optimize the overlapping between all structured zones defined in a pyTree t.
The &#8216;cellN&#8217; variable located at cell centers is modified, such that cellN=2 for a cell interpolable from another zone.
Double wall projection technique is activated if &#8216;double_wall&#8217;=1. Parameter planarTol can be useful for double wall cases,
in the case when double wall surfaces are planar but distant from planarTol to each other.
The overlapping is optimized between zones from separated bases, and is based on a priority to the cell of smallest size.
One can impose a priority to a base over another base, using the list priorities.
For instance, priorities = [&#8216;baseName1&#8217;,0, &#8216;baseName2&#8217;,1] means that zones from base of name &#8216;baseName1&#8217; are preferred over
zones from base of name &#8216;baseName2&#8217;:</p>
</div></blockquote>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/optimizeOverlap.py">Optimize overlapping (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - optimizeOverlap (array) -</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Generator</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Transform</span> <span class="k">as</span> <span class="nn">T</span>
<span class="kn">import</span> <span class="nn">Connector</span> <span class="k">as</span> <span class="nn">X</span>

<span class="n">Ni</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span> <span class="n">Nj</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span> <span class="n">Nk</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">Ni</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">Nj</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">Ni</span><span class="p">,</span><span class="n">Nj</span><span class="p">,</span><span class="n">Nk</span><span class="p">))</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mf">2.</span><span class="o">/</span><span class="p">(</span><span class="n">Ni</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mf">2.</span><span class="o">/</span><span class="p">(</span><span class="n">Nj</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">Ni</span><span class="p">,</span><span class="n">Nj</span><span class="p">,</span><span class="n">Nk</span><span class="p">))</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="mf">10.</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>

<span class="n">ca</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">node2Center</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="n">ca</span> <span class="o">=</span>  <span class="n">C</span><span class="o">.</span><span class="n">initVars</span><span class="p">(</span><span class="n">ca</span><span class="p">,</span> <span class="s1">&#39;cellN&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
<span class="n">cb</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">node2Center</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="n">cb</span> <span class="o">=</span>  <span class="n">C</span><span class="o">.</span><span class="n">initVars</span><span class="p">(</span><span class="n">cb</span><span class="p">,</span> <span class="s1">&#39;cellN&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">optimizeOverlap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ca</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">cb</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="s2">&quot;out.plt&quot;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/optmimizeOverlapPT.py">Optimize overlapping (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - optimizeOverlap (pyTree) -</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Transform.PyTree</span> <span class="k">as</span> <span class="nn">T</span>
<span class="kn">import</span> <span class="nn">Connector.PyTree</span> <span class="k">as</span> <span class="nn">X</span>

<span class="n">Ni</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span> <span class="n">Nj</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span> <span class="n">Nk</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">Ni</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">Nj</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">Ni</span><span class="p">,</span><span class="n">Nj</span><span class="p">,</span><span class="n">Nk</span><span class="p">))</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mf">2.</span><span class="o">/</span><span class="p">(</span><span class="n">Ni</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mf">2.</span><span class="o">/</span><span class="p">(</span><span class="n">Nj</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">Ni</span><span class="p">,</span><span class="n">Nj</span><span class="p">,</span><span class="n">Nk</span><span class="p">));</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cart2&#39;</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="mf">10.</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Base1&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="s1">&#39;Base2&#39;</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">optimizeOverlap</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;out.cgns&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Connector.maximizeBlankedCells">
<span class="sig-prename descclassname"><span class="pre">Connector.</span></span><span class="sig-name descname"><span class="pre">maximizeBlankedCells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Change useless interpolated points status (2) to blanked points (0).
If dir=0, uses a directional stencil of depth points, if dir=1,
uses a full depth x depth x depth stencil.</p>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/maximizeBlankedCells.py">Maximize blanked cells (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - maximizeBlankedCells (array) -</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Connector</span> <span class="k">as</span> <span class="nn">X</span>
<span class="kn">import</span> <span class="nn">Generator</span> <span class="k">as</span> <span class="nn">G</span>

<span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">):</span> <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="mi">2</span>

<span class="n">Ni</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span> <span class="n">Nj</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">Ni</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">Nj</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">),(</span><span class="n">Ni</span><span class="p">,</span><span class="n">Nj</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">initVars</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;cellN&#39;</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;y&#39;</span><span class="p">])</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">maximizeBlankedCells</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">([</span><span class="n">a</span><span class="p">],</span> <span class="s1">&#39;out.plt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/maximizeBlankedCellsPT.py">Maximize blanked cells (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - maximizeBlankedCells (pyTree) -</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Connector.PyTree</span> <span class="k">as</span> <span class="nn">X</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>

<span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">):</span> <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="mi">2</span>

<span class="n">Ni</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span> <span class="n">Nj</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">Ni</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">Nj</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">),(</span><span class="n">Ni</span><span class="p">,</span><span class="n">Nj</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">initVars</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="s1">&#39;cellN&#39;</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span>
               <span class="p">[</span><span class="s1">&#39;CoordinateX&#39;</span><span class="p">,</span><span class="s1">&#39;CoordinateY&#39;</span><span class="p">])</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">node2Center</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;cellN&#39;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">rmVars</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="s1">&#39;cellN&#39;</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Base&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">]);</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">maximizeBlankedCells</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Connector.setDoublyDefinedBC">
<span class="sig-prename descclassname"><span class="pre">Connector.</span></span><span class="sig-name descname"><span class="pre">setDoublyDefinedBC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cellN</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">listOfInterpZones</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">listOfCelln</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">range</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>When a border of zone z is defined by doubly defined BC in range=[i1,i2,j1,j2,k1,k2],
one can determine whether a point is interpolated or defined by the physical BC. The array cellN defines the cell nature field at centers for zone z.
If a cell is interpolable from a donor zone, then the cellN is set to 2 for this cell.
The lists listOfInterpZones and listOfCelln are the list of arrays defining the interpolation domains, and corresponding cell nature fields. depth can be 1 or 2. If case of depth=2,
if one point of the two layers is not interpolable, then celln is set to 1 for both points:</p>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/setDoublyDefinedBC.py">Set interpolated/BC points on doubly defined BCs (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - setDoublyDefinedBC (array) -</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Connector</span> <span class="k">as</span> <span class="nn">X</span>
<span class="kn">import</span> <span class="nn">Generator</span> <span class="k">as</span> <span class="nn">G</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mf">2.5</span><span class="p">,</span><span class="mf">2.5</span><span class="p">,</span><span class="o">-</span><span class="mf">2.5</span><span class="p">),(</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">),(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">30</span><span class="p">))</span>
<span class="n">celln</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;cellN&#39;</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">celln</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">initVars</span><span class="p">(</span><span class="n">celln</span><span class="p">,</span> <span class="s1">&#39;cellN&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">indmax</span> <span class="o">=</span> <span class="n">celln</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">celln</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="n">celln</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="n">indmax</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">cellnb</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;cellN&#39;</span><span class="p">,</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">b</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">cellnb</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">initVars</span><span class="p">(</span><span class="n">cellnb</span><span class="p">,</span> <span class="s1">&#39;cellN&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">celln</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">setDoublyDefinedBC</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">celln</span><span class="p">,</span> <span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="p">[</span><span class="n">cellnb</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ac</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">node2Center</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">ac</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addVars</span><span class="p">([</span><span class="n">ac</span><span class="p">,</span><span class="n">celln</span><span class="p">])</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">([</span><span class="n">ac</span><span class="p">],</span> <span class="s1">&#39;out.plt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/setDoublyDefinedBCPT.py">Set interpolated/BC points on doubly defined BCs (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - setDoublyDefinedBC (pyTree) -</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Connector.PyTree</span> <span class="k">as</span> <span class="nn">X</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Transform.PyTree</span> <span class="k">as</span> <span class="nn">T</span>
<span class="kn">import</span> <span class="nn">Converter.Internal</span> <span class="k">as</span> <span class="nn">Internal</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mf">2.5</span><span class="p">,</span><span class="mf">2.5</span><span class="p">,</span><span class="o">-</span><span class="mf">2.5</span><span class="p">),(</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">),(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">30</span><span class="p">));</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;fente&#39;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">splitNParts</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">_addBC2Zone</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;overlap1&#39;</span><span class="p">,</span> <span class="s1">&#39;BCOverlap&#39;</span><span class="p">,</span> <span class="s1">&#39;kmin&#39;</span><span class="p">,</span> <span class="n">zoneDonor</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;FamilySpecified:FENTE&#39;</span><span class="p">],</span> <span class="n">rangeDonor</span><span class="o">=</span><span class="s1">&#39;doubly_defined&#39;</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Base1&#39;</span><span class="p">,</span><span class="s1">&#39;Base2&#39;</span><span class="p">])</span>
<span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">+=</span><span class="n">b</span>
<span class="n">C</span><span class="o">.</span><span class="n">_addFamily2Base</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;FENTE&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">Internal</span><span class="o">.</span><span class="n">getZones</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]):</span> <span class="n">C</span><span class="o">.</span><span class="n">_tagWithFamily</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="s1">&#39;FENTE&#39;</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">_initVars</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;centers:cellN&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">applyBCOverlaps</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">setDoublyDefinedBC</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Connector.blankIntersectingCells">
<span class="sig-prename descclassname"><span class="pre">Connector.</span></span><span class="sig-name descname"><span class="pre">blankIntersectingCells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cellN</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.e-10</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Blank intersecting cells of a 3D mesh. Only faces normal to k-planes for structured meshes and faces normal to triangular faces for prismatic meshes, and faces normal to 1234 and 5678 faces for hexahedral meshes are tested.
The cellN is set to 0 for intersecting cells/elements. Input data are A the list of meshes, cellN the list of cellNatureField located at cell centers.
Array version: the cellN must be an array located at centers, defined separately</p>
<p>Blank intersecting cells of a 3D mesh. Only faces normal to k-planes for structured meshes and faces normal to triangular faces for prismatic meshes,
and faces normal to 1234 and 5678 faces for hexahedral meshes are tested. Set the cellN to 0 for intersecting cells/elements. Input data are A the list of meshes, cellN the list of cellNatureField located at cell centers:
The cellN variable is defined as a FlowSolution#Center node. The cellN is set to 0 for intersecting and negative volume cells:</p>
<p>a = X.blankIntersectingCells(a, tol=1.e-10, depth=2)</p>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/blankIntersectingCells.py">Blank intersecting cells (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - blankIntersectingCells (array)</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Generator</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Transform</span> <span class="k">as</span> <span class="nn">T</span>
<span class="kn">import</span> <span class="nn">Connector</span> <span class="k">as</span> <span class="nn">X</span>
<span class="n">a1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">),(</span><span class="mi">11</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">11</span><span class="p">))</span>
<span class="n">a2</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">),</span><span class="mf">10.</span><span class="p">)</span>
<span class="n">a2</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="p">(</span><span class="mf">7.</span><span class="p">,</span><span class="mf">5.</span><span class="p">,</span><span class="mf">5.</span><span class="p">))</span>
<span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="n">a1</span><span class="p">,</span><span class="n">a2</span><span class="p">]</span>
<span class="n">Ac</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">node2Center</span><span class="p">(</span><span class="n">A</span><span class="p">);</span> <span class="n">Ac</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">initVars</span><span class="p">(</span><span class="n">Ac</span><span class="p">,</span><span class="s1">&#39;cellN&#39;</span><span class="p">,</span><span class="mf">1.</span><span class="p">);</span>
<span class="n">Ac</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">blankIntersectingCells</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">Ac</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1.e-10</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">(</span><span class="n">Ac</span><span class="p">,</span><span class="s2">&quot;out.plt&quot;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/blankIntersectingCellsPT.py">Blank intersecting cells (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - blankIntersectingCells (pyTree)</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Transform.PyTree</span> <span class="k">as</span> <span class="nn">T</span>
<span class="kn">import</span> <span class="nn">Connector.PyTree</span> <span class="k">as</span> <span class="nn">X</span>

<span class="n">a1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">),(</span><span class="mi">11</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">11</span><span class="p">))</span>
<span class="n">a2</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">),</span><span class="mf">10.</span><span class="p">)</span>
<span class="n">a2</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="p">(</span><span class="mf">7.</span><span class="p">,</span><span class="mf">5.</span><span class="p">,</span><span class="mf">5.</span><span class="p">));</span> <span class="n">a1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cart1&#39;</span><span class="p">;</span> <span class="n">a2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cart2&#39;</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Base&#39;</span><span class="p">,</span><span class="n">a1</span><span class="p">,</span><span class="n">a2</span><span class="p">])</span>
<span class="n">C</span><span class="o">.</span><span class="n">_initVars</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="s1">&#39;centers:cellN&#39;</span><span class="p">,</span><span class="mf">1.</span><span class="p">)</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">blankIntersectingCells</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1.e-10</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="s2">&quot;out.cgns&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Connector.getIntersectingDomains">
<span class="sig-prename descclassname"><span class="pre">Connector.</span></span><span class="sig-name descname"><span class="pre">getIntersectingDomains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'AABB'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">taabb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tobb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">taabb2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tobb2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Create a Python dictionary describing the intersecting zones. If t2 is not provided, then the computed dictionary states the self-intersecting zone names, otherwise, it
computes the intersection between t and t2. Mode can be &#8216;AABB&#8217;, for Axis-Aligned Bounding Box method, &#8216;OBB&#8217; for Oriented Bounding Box method, or &#8216;hybrid&#8217;, using a combination
of AABB and OBB which gives the most accurate result. Depending on the selected mode, the user can provide the corresponding AABB and/or OBB PyTrees of t and/or t2, so that the
algorithm will reuse those BB PyTrees instead of calculating them.</p>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/getIntersectingDomains.py">Create intersection dictionary (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - getIntersectingDomainsAABB (array) -</span>
<span class="kn">import</span> <span class="nn">Generator</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Connector</span> <span class="k">as</span> <span class="nn">X</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mf">9.</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>

<span class="n">bb</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">BB</span><span class="p">([</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">])</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">getIntersectingDomainsAABB</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/getIntersectingDomainsPT.py">Create intersection dictionary (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - getIntersectingDomains (pyTree) -</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Connector.PyTree</span> <span class="k">as</span> <span class="nn">X</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Base1&#39;</span><span class="p">])</span>
<span class="n">Ni</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">Nj</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">Nk</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">dx</span> <span class="o">=</span> <span class="mf">0.</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="n">dx</span><span class="p">,</span><span class="n">dx</span><span class="p">,</span><span class="n">dx</span><span class="p">),(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">Ni</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">Nj</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">Nk</span><span class="o">-</span><span class="mi">1</span><span class="p">)),</span> <span class="p">(</span><span class="n">Ni</span><span class="p">,</span><span class="n">Nj</span><span class="p">,</span><span class="n">Nk</span><span class="p">))</span>
    <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">z</span><span class="p">]</span>
    <span class="n">dx</span> <span class="o">+=</span> <span class="mf">0.3</span>

<span class="n">interDict</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">getIntersectingDomains</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;hybrid&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Does cart.1 intersect cart.2 ?&#39;</span><span class="p">,</span><span class="s1">&#39;cart.1&#39;</span> <span class="ow">in</span> <span class="n">interDict</span><span class="p">[</span><span class="s1">&#39;cart.2&#39;</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;List of zones intersecting cart.2:&#39;</span><span class="p">,</span> <span class="n">interDict</span><span class="p">[</span><span class="s1">&#39;cart.2&#39;</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Connector.getCEBBIntersectingDomains">
<span class="sig-prename descclassname"><span class="pre">Connector.</span></span><span class="sig-name descname"><span class="pre">getCEBBIntersectingDomains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sameBase</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Detect the domains defined in the list of bases B whose CEBB
intersect domains defined in base A.
Return the list of zone names for each basis.
If sameBase=1, the intersecting domains are also searched in base:</p>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/getCEBBIntersectingDomainsPT.py">detect CEBB intersection between bases (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - getCEBBIntersectingDomains (pyTree) -</span>
<span class="kn">import</span> <span class="nn">Connector.PyTree</span> <span class="k">as</span> <span class="nn">X</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Converter.Internal</span> <span class="k">as</span> <span class="nn">Internal</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),(</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">),(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">));</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cart1&#39;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),(</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">),(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">));</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cart2&#39;</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mf">0.75</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),(</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">),(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">));</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cart3&#39;</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Cart&#39;</span><span class="p">]);</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>
<span class="n">bases</span> <span class="o">=</span> <span class="n">Internal</span><span class="o">.</span><span class="n">getNodesFromType</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;CGNSBase_t&#39;</span><span class="p">)</span>
<span class="n">base</span> <span class="o">=</span> <span class="n">bases</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">doms</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">getCEBBIntersectingDomains</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="nb">print</span><span class="p">(</span><span class="n">doms</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Connector.X.getCEBBTimeIntersectingDomains">
<span class="sig-prename descclassname"><span class="pre">X.</span></span><span class="sig-name descname"><span class="pre">getCEBBTimeIntersectingDomains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bases</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">funcs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inititer=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">niter=1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt=1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sameBase</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>in a Chimera pre-processing for bodies in relative motion,
it can be useful to determine intersecting domains at any iteration.
niter defines the number of iterations on which CEBB intersections are detected, starting from iteration inititer.
dt defines the timestep.
func defines a python function defining the motion of base, funcs is the list of python functions describing motions for bases.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<ol class="arabic simple">
<li><p>motions here are only relative motions. If all bases are translated with the same translation motion, it must not be defined in func.</p></li>
<li><p>If no motion is defined on a basis, then the corresponding function must be []:</p></li>
</ol>
</div>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/getCEBBTimeIntersectingDomainsPT.py">CEBB intersection between bases with motions (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - getCEBBIntersectingDomains (pyTree) -</span>
<span class="kn">import</span> <span class="nn">Connector.PyTree</span> <span class="k">as</span> <span class="nn">X</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Converter.Internal</span> <span class="k">as</span> <span class="nn">Internal</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span>

<span class="c1"># Coordonnees du centre de rotation dans le repere absolu</span>
<span class="k">def</span> <span class="nf">centerAbs</span><span class="p">(</span><span class="n">t</span><span class="p">):</span> <span class="k">return</span> <span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

<span class="c1"># Coordonnees du centre de la rotation dans le repere entraine</span>
<span class="k">def</span> <span class="nf">centerRel</span><span class="p">(</span><span class="n">t</span><span class="p">):</span> <span class="k">return</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

<span class="c1"># Matrice de rotation</span>
<span class="k">def</span> <span class="nf">rot</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="mf">30.</span>
    <span class="n">m</span> <span class="o">=</span> <span class="p">[[</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">t</span><span class="p">),</span> <span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">t</span><span class="p">),</span> <span class="mi">0</span><span class="p">],</span>
         <span class="p">[</span><span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">t</span><span class="p">),</span> <span class="n">cos</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">t</span><span class="p">),</span>  <span class="mi">0</span><span class="p">],</span>
         <span class="p">[</span><span class="mi">0</span><span class="p">,</span>            <span class="mi">0</span><span class="p">,</span>             <span class="mi">1</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">m</span>

<span class="c1"># Mouvement complet</span>
<span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="n">t</span><span class="p">):</span> <span class="k">return</span> <span class="p">(</span><span class="n">centerAbs</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">centerRel</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">rot</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cylinder</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">360.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="c1"># --- CL</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addBC2Zone</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="s1">&#39;wall&#39;</span><span class="p">,</span><span class="s1">&#39;BCWall&#39;</span><span class="p">,</span><span class="s1">&#39;jmin&#39;</span><span class="p">)</span>
<span class="c1"># --- champ aux noeuds</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Cylindre&#39;</span><span class="p">]);</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="c1"># --- Equation state</span>
<span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;EquationDimension&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cylinder</span><span class="p">((</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">360.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">,</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="c1"># --- champ aux centres</span>
<span class="c1"># --- CL</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addBC2Zone</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="s1">&#39;wall&#39;</span><span class="p">,</span><span class="s1">&#39;BCWall&#39;</span><span class="p">,</span><span class="s1">&#39;jmin&#39;</span><span class="p">)</span>
<span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="s1">&#39;cylinder2&#39;</span>
<span class="c1">#</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mf">1.</span><span class="p">;</span> <span class="n">Funcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">F</span><span class="p">,[]]</span>
<span class="n">b1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="o">-</span><span class="mf">2.</span><span class="p">,</span><span class="o">-</span><span class="mf">2.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),(</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">0.4</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">11</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">b2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="o">-</span><span class="mf">4.</span><span class="p">,</span><span class="o">-</span><span class="mf">2.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),(</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">0.4</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">11</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">b3</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mf">2.</span><span class="p">,</span><span class="o">-</span><span class="mf">2.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),(</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">0.4</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">11</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">b4</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="o">-</span><span class="mf">2.</span><span class="p">,</span><span class="o">-</span><span class="mf">2.</span><span class="p">,</span><span class="mf">3.</span><span class="p">),(</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">0.4</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">11</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">b5</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="o">-</span><span class="mf">4.</span><span class="p">,</span><span class="o">-</span><span class="mf">2.</span><span class="p">,</span><span class="mf">3.</span><span class="p">),(</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">0.4</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">11</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="n">b6</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mf">2.</span><span class="p">,</span><span class="o">-</span><span class="mf">2.</span><span class="p">,</span><span class="mf">3.</span><span class="p">),(</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">0.4</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">11</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="c1">#</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addBase2PyTree</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="s1">&#39;Cart&#39;</span><span class="p">);</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">b1</span><span class="p">,</span><span class="n">b2</span><span class="p">,</span><span class="n">b3</span><span class="p">,</span><span class="n">b4</span><span class="p">,</span><span class="n">b5</span><span class="p">,</span><span class="n">b6</span><span class="p">]</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">initVars</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;centers:cellN&#39;</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">initVars</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;Density&#39;</span><span class="p">,</span> <span class="mf">2.</span><span class="p">)</span>
<span class="n">bases</span> <span class="o">=</span> <span class="n">Internal</span><span class="o">.</span><span class="n">getNodesFromType</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="s1">&#39;CGNSBase_t&#39;</span><span class="p">);</span> <span class="n">base</span> <span class="o">=</span> <span class="n">bases</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">doms</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">getCEBBTimeIntersectingDomains</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">Funcs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">sameBase</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">doms</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Connector.X.applyBCOverlaps">
<span class="sig-prename descclassname"><span class="pre">X.</span></span><span class="sig-name descname"><span class="pre">applyBCOverlaps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'centers'</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>set the cellN to 2 for the fringe nodes or cells (depending on parameter &#8216;loc&#8217;=&#8217;nodes&#8217; or &#8216;centers&#8217;) near the overlap borders defined in the pyTree t.
Parameter &#8216;depth&#8217; defines the number of layers of interpolated points.</p>
<p>Exists also as in place version (_applyBCOverlaps) that modifies a and returns None.</p>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/applyBCOverlapsPT.py">set cellN to 2 near overlap BCs in a pyTree (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - applyBCOverlaps (pyTree) -</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Connector.PyTree</span> <span class="k">as</span> <span class="nn">X</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cylinder</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">360.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addBC2Zone</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;overlap1&#39;</span><span class="p">,</span> <span class="s1">&#39;BCOverlap&#39;</span><span class="p">,</span> <span class="s1">&#39;jmin&#39;</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Base&#39;</span><span class="p">,</span><span class="n">a</span><span class="p">])</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">applyBCOverlaps</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Connector.X.setDoublyDefinedBC">
<span class="sig-prename descclassname"><span class="pre">X.</span></span><span class="sig-name descname"><span class="pre">setDoublyDefinedBC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>when a border is defined by doubly defined BC, one can determine whether a point is interpolated or defined by the physical BC. The cellN is set to
2 if cells near the doubly defined BC are interpolable from a specified donor zone:</p>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/setDoublyDefinedBCPT.py">set interpolated/BC points on doubly defined BCs (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - setDoublyDefinedBC (pyTree) -</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Connector.PyTree</span> <span class="k">as</span> <span class="nn">X</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Transform.PyTree</span> <span class="k">as</span> <span class="nn">T</span>
<span class="kn">import</span> <span class="nn">Converter.Internal</span> <span class="k">as</span> <span class="nn">Internal</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mf">2.5</span><span class="p">,</span><span class="mf">2.5</span><span class="p">,</span><span class="o">-</span><span class="mf">2.5</span><span class="p">),(</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">),(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">30</span><span class="p">));</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;fente&#39;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">splitNParts</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">_addBC2Zone</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;overlap1&#39;</span><span class="p">,</span> <span class="s1">&#39;BCOverlap&#39;</span><span class="p">,</span> <span class="s1">&#39;kmin&#39;</span><span class="p">,</span> <span class="n">zoneDonor</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;FamilySpecified:FENTE&#39;</span><span class="p">],</span> <span class="n">rangeDonor</span><span class="o">=</span><span class="s1">&#39;doubly_defined&#39;</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Base1&#39;</span><span class="p">,</span><span class="s1">&#39;Base2&#39;</span><span class="p">])</span>
<span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">+=</span><span class="n">b</span>
<span class="n">C</span><span class="o">.</span><span class="n">_addFamily2Base</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;FENTE&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">Internal</span><span class="o">.</span><span class="n">getZones</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]):</span> <span class="n">C</span><span class="o">.</span><span class="n">_tagWithFamily</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="s1">&#39;FENTE&#39;</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">_initVars</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;centers:cellN&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">applyBCOverlaps</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">setDoublyDefinedBC</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Connector.PyTree.cellN2OversetHoles">
<span class="sig-prename descclassname"><span class="pre">Connector.PyTree.</span></span><span class="sig-name descname"><span class="pre">cellN2OversetHoles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Compute the OversetHoles node into a pyTree from the cellN field, located at nodes or centers. For structured zones, defines it as a list of ijk indices, located at nodes or centers.
For unstructured zones, defines the OversetHoles node as a list of indices ind, defining the cell vertices that are of cellN=0 if the cellN is located at nodes, and defining the cell centers that are of cellN=0 if the cellN is located at centers.</p>
<p>The OversetHoles nodes can be then dumped to files, defined by the indices of blanked nodes or cells.</p>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/cellN2OversetHolesPT.py">Create overset hole nodes (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - cellN2OversetHoles (pyTree) -</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Connector.PyTree</span> <span class="k">as</span> <span class="nn">X</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">C</span><span class="o">.</span><span class="n">_initVars</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;centers:cellN&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">cellN2OversetHoles</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/cellN2OversetHolesPT2.py">Dump overset hole nodes to file (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - cellN2OversetHoles (pyTree) -</span>
<span class="c1"># - Dumping the OversetHoles node to files -</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Connector.PyTree</span> <span class="k">as</span> <span class="nn">X</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Converter.Internal</span> <span class="k">as</span> <span class="nn">Internal</span>
<span class="kn">import</span> <span class="nn">Converter</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Base1&#39;</span><span class="p">,</span><span class="s1">&#39;Base2&#39;</span><span class="p">])</span>
<span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addBC2Zone</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;overlap1&#39;</span><span class="p">,</span> <span class="s1">&#39;BCOverlap&#39;</span><span class="p">,</span> <span class="s1">&#39;imin&#39;</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">_initVars</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;centers:cellN&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">applyBCOverlaps</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">cellN2OversetHoles</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

<span class="n">zones</span> <span class="o">=</span> <span class="n">Internal</span><span class="o">.</span><span class="n">getNodesFromType</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;Zone_t&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">zones</span><span class="p">:</span>
    <span class="n">ho</span> <span class="o">=</span> <span class="n">Internal</span><span class="o">.</span><span class="n">getNodesFromType</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="s1">&#39;OversetHoles_t&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ho</span> <span class="o">!=</span> <span class="p">[]:</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">ho</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">array</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;cell_index&#39;</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">Converter</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">([</span><span class="n">array</span><span class="p">],</span> <span class="s1">&#39;hole_&#39;</span><span class="o">+</span><span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;.v3d&#39;</span><span class="p">,</span>
                                     <span class="s1">&#39;bin_v3d&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Connector.PyTree.setInterpData">
<span class="sig-prename descclassname"><span class="pre">Connector.PyTree.</span></span><span class="sig-name descname"><span class="pre">setInterpData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">aR</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aD</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">penalty</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nature</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extrap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'nodes'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">storage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'direct'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">topTreeRcv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">topTreeDnr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sameName</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Compute and store in a pyTree the interpolation information (donor and receptor points, interpolation type, interpolation coefficients) given receptors defined by aR,
donor zones given by aD. If storage=&#8217;direct&#8217;, then aR with interpolation data stored in receptor zones are returned, and if storage=&#8217;inverse&#8217;, then aD with interpolation data stored in donor zones are returned.
Donor zones can be structured or unstructured TETRA. receptor zones can be structured or unstructured.</p>
<p>Interpolation order can be 2, 3 or 5 for structured donor zones, only order=2 for unstructured donor zones is performed.</p>
<p>Parameter loc can &#8216;nodes&#8217; or &#8216;centers&#8217;, meaning that receptor points are zone nodes or centers.</p>
<p>penalty=1 means that a candidate donor cell located at a zone border is penalized against interior candidate cell.</p>
<p>nature=0 means that a candidate donor cell containing a blanked point(cellN=0) is not valid. If nature=1 all the nodes of the candidate donor cell must be cellN=1 to be valid.</p>
<p>extrap=1 means that extrapolation is enabled.</p>
<p>If sameName=1, interpolation from donor zones with the same name as
receptor zones are avoided.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>currently, no periodic Chimera taken into account by this function automatically.</p>
</div>
<p>Interpolation data are stored as a ZoneSubRegion_t node, stored under the donor or receptor zone node depending of the storage.</p>
<p>Exists also as in place version (_setInterpData) that modifies a and return None.
Exists also as parallel distributed version (X.Mpi.setInterpData and X.Mpi._setInterpData).</p>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/setInterpDataPT.py">Compute interpolation connectivity (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - setInterpData (pyTree) -</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Connector.PyTree</span> <span class="k">as</span> <span class="nn">X</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cylinder</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mf">1.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mi">360</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,(</span><span class="mi">200</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">2</span><span class="p">));</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cylindre1&#39;</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addBC2Zone</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;wall1&#39;</span><span class="p">,</span> <span class="s1">&#39;BCWall&#39;</span><span class="p">,</span> <span class="s1">&#39;jmin&#39;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addBC2Zone</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;ov1&#39;</span><span class="p">,</span> <span class="s1">&#39;BCOverlap&#39;</span><span class="p">,</span> <span class="s1">&#39;jmax&#39;</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cylinder</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mf">1.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mi">360</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,(</span><span class="mi">200</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">2</span><span class="p">));</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cylindre2&#39;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addBC2Zone</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">&#39;wall1&#39;</span><span class="p">,</span> <span class="s1">&#39;BCWall&#39;</span><span class="p">,</span> <span class="s1">&#39;jmin&#39;</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addBC2Zone</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">&#39;ov1&#39;</span><span class="p">,</span> <span class="s1">&#39;BCOverlap&#39;</span><span class="p">,</span> <span class="s1">&#39;jmax&#39;</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="o">-</span><span class="mf">5.</span><span class="p">,</span><span class="o">-</span><span class="mf">7.5</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mf">15.</span><span class="o">/</span><span class="mi">200</span><span class="p">,</span><span class="mf">15.</span><span class="o">/</span><span class="mi">200</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="mi">200</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Corps1&#39;</span><span class="p">,</span> <span class="s1">&#39;Corps2&#39;</span><span class="p">,</span> <span class="s1">&#39;Bgrd&#39;</span><span class="p">])</span>
<span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">connectMatch</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">fillEmptyBCWith</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;nref&#39;</span><span class="p">,</span> <span class="s1">&#39;BCFarfield&#39;</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">applyBCOverlaps</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">setInterpData</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">:],</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;centers&#39;</span><span class="p">,</span> <span class="n">storage</span><span class="o">=</span><span class="s1">&#39;inverse&#39;</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;out.cgns&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Connector.PyTree.setInterpData2">
<span class="sig-prename descclassname"><span class="pre">Connector.PyTree.</span></span><span class="sig-name descname"><span class="pre">setInterpData2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">aR</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aD</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'centers'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cartesian</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Compute and store in a pyTree the interpolation data between two trees/bases/zones and store them in aD.
Only points from aR that are cellN=2 are interpolated. If cellN is not defined in aR, all the points are interpolated.
Donor zones can be either structured or TETRA while receptor zones can be either structured or unstructured.</p>
<p>Interpolation order can be 2, 3 or 5 for structured donor zones, only order=2 for unstructured donor zones is performed.</p>
<p>Parameter loc can &#8216;nodes&#8217; or &#8216;centers&#8217;, meaning that interpolated fields in aR will be located at nodes/centers respectively</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>currently, no periodic Chimera taken into account by this function automatically.</p>
</div>
<p>Interpolation data are stored as a ZoneSubRegion_t node, stored under the donor or receptor zone node depending of the storage.</p>
<p>Exists also as in place version (_setInterpData2) that modifies a and return None.
Exists also as parallel distributed version (X.Mpi.setInterpData2 and X.Mpi._setInterpData2).
<em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/setInterpData2PT.py">Compute interpolation connectivity (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - setInterpData2 (pyTree) -</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Connector.PyTree</span> <span class="k">as</span> <span class="nn">X</span>

<span class="n">aD</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">11</span><span class="p">))</span>
<span class="n">aR</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">),</span> <span class="p">(</span><span class="mi">21</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">21</span><span class="p">))</span>
<span class="n">X</span><span class="o">.</span><span class="n">_setInterpData2</span><span class="p">(</span><span class="n">aR</span><span class="p">,</span> <span class="n">aD</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;centers&#39;</span><span class="p">,</span> <span class="n">cartesian</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">aD</span><span class="p">,</span> <span class="s2">&quot;out.cgns&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Connector.PyTree.getOversetInfo">
<span class="sig-prename descclassname"><span class="pre">Connector.PyTree.</span></span><span class="sig-name descname"><span class="pre">getOversetInfo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tR</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tD</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'interpolated'</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Set information on Chimera connectivity, i.e. interpolated, extrapolated or orphan cells, donor aspect ratio and ratio between volume of donor and receptor cells.
This function is compliant with the storage as defined for setInterpData function.
If type=&#8217;interpolated&#8217;, variable &#8216;interpolated&#8217; is created and is equal to 1 for interpolated and extrapolated points, 0 otherwise.
If type=&#8217;extrapolated&#8217;, variable &#8216;extrapolated&#8217; is created and its value is the sum of the absolute values of coefficients, 0 otherwise.
If type=&#8217;orphan&#8217;, variable &#8216;orphan&#8217; is created and is equal to 1 for orphan points,  0 otherwise.
If type=&#8217;cellRatio&#8217;, variable &#8216;cellRatio&#8217; is created and is equal to max(volD/volR,volR/volD) for interpolated and extrapolated points (volR and volD are volume of receptors and donors).
If type=&#8217;donorAspect&#8217;, variable &#8216;donorAspect&#8217; is created and is equal to the ratio between the maximum and minimum length of donors, and 0 for points that are not interpolated.</p>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/getOversetInfoPT.py">Get overset information (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - getOversetInfo (pyTree) -</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Connector.PyTree</span> <span class="k">as</span> <span class="nn">X</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cylinder</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mf">1.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mi">360</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,(</span><span class="mi">200</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">4</span><span class="p">));</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cylindre1&#39;</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addBC2Zone</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;wall1&#39;</span><span class="p">,</span> <span class="s1">&#39;BCWall&#39;</span><span class="p">,</span> <span class="s1">&#39;jmin&#39;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addBC2Zone</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;ov1&#39;</span><span class="p">,</span> <span class="s1">&#39;BCOverlap&#39;</span><span class="p">,</span> <span class="s1">&#39;jmax&#39;</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cylinder</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mf">1.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mi">360</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,(</span><span class="mi">200</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">4</span><span class="p">));</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cylindre2&#39;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addBC2Zone</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">&#39;wall1&#39;</span><span class="p">,</span> <span class="s1">&#39;BCWall&#39;</span><span class="p">,</span> <span class="s1">&#39;jmin&#39;</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addBC2Zone</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">&#39;ov1&#39;</span><span class="p">,</span> <span class="s1">&#39;BCOverlap&#39;</span><span class="p">,</span> <span class="s1">&#39;jmax&#39;</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="o">-</span><span class="mf">5.</span><span class="p">,</span><span class="o">-</span><span class="mf">7.5</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mf">15.</span><span class="o">/</span><span class="mi">200</span><span class="p">,</span><span class="mf">15.</span><span class="o">/</span><span class="mi">200</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="mi">200</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Corps1&#39;</span><span class="p">,</span> <span class="s1">&#39;Corps2&#39;</span><span class="p">,</span> <span class="s1">&#39;Bgrd&#39;</span><span class="p">])</span>
<span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">connectMatch</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">fillEmptyBCWith</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;nref&#39;</span><span class="p">,</span> <span class="s1">&#39;BCFarfield&#39;</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">applyBCOverlaps</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;centers&#39;</span><span class="p">)</span>
<span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">setInterpData</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">t</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;centers&#39;</span><span class="p">,</span>
                             <span class="n">storage</span><span class="o">=</span><span class="s1">&#39;direct&#39;</span><span class="p">,</span> <span class="n">sameName</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">getOversetInfo</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;centers&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;interpolated&#39;</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">getOversetInfo</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;centers&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;orphan&#39;</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;out.cgns&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Connector.PyTree.extractChimeraInfo">
<span class="sig-prename descclassname"><span class="pre">Connector.PyTree.</span></span><span class="sig-name descname"><span class="pre">extractChimeraInfo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'interpolated'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'centers'</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Extract some Chimera information (interpolated, extrapolated, orphan points or extrapolated points with a sum of coefficients greater than a given value).
Function chimeraInfo or oversetInfo must be applied first to compute the interpolated/extrapolated/orphan fields.
Information is extracted as &#8216;NODE&#8217;-type zones, whose names are suffixed by the original zone names.
If no zone is extracted, returns [].
Location loc must be compliant with the location of interpolation data (i.e. location of Chimera receptor points).</p>
<p>If type=&#8217;interpolated&#8217;, interpolated and extrapolated points are extracted.
If type=&#8217;extrapolated&#8217;, extrapolated points are extracted.
If type=&#8217;orphan&#8217;, orphan points are extracted.
If type=&#8217;cf&gt;value&#8217;,  extrapolated points where the sum of absolute coefficients is greater than value are extracted.</p>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/extractChimeraInfoPT.py">Extract chimera points (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - chimeraInfo (pyTree) -</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Connector.PyTree</span> <span class="k">as</span> <span class="nn">X</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cylinder</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mf">1.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mi">360</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,(</span><span class="mi">200</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">4</span><span class="p">));</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cylindre1&#39;</span>
<span class="n">C</span><span class="o">.</span><span class="n">_addBC2Zone</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;wall1&#39;</span><span class="p">,</span> <span class="s1">&#39;BCWall&#39;</span><span class="p">,</span> <span class="s1">&#39;jmin&#39;</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">_addBC2Zone</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;ov1&#39;</span><span class="p">,</span> <span class="s1">&#39;BCOverlap&#39;</span><span class="p">,</span> <span class="s1">&#39;jmax&#39;</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cylinder</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mf">1.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mi">360</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,(</span><span class="mi">200</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">4</span><span class="p">));</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cylindre2&#39;</span>
<span class="n">C</span><span class="o">.</span><span class="n">_addBC2Zone</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">&#39;wall1&#39;</span><span class="p">,</span> <span class="s1">&#39;BCWall&#39;</span><span class="p">,</span> <span class="s1">&#39;jmin&#39;</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">_addBC2Zone</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">&#39;ov1&#39;</span><span class="p">,</span> <span class="s1">&#39;BCOverlap&#39;</span><span class="p">,</span> <span class="s1">&#39;jmax&#39;</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Cyl1&#39;</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="s1">&#39;Cyl2&#39;</span><span class="p">,</span><span class="n">b</span><span class="p">])</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">connectMatch</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">_fillEmptyBCWith</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="s1">&#39;nref&#39;</span><span class="p">,</span><span class="s1">&#39;BCFarfield&#39;</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">_initVars</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="s1">&#39;centers:cellN&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">setInterpolations</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="n">double_wall</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">storage</span><span class="o">=</span><span class="s1">&#39;direct&#39;</span><span class="p">)</span>
<span class="n">X</span><span class="o">.</span><span class="n">_chimeraInfo</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;orphan&#39;</span><span class="p">)</span>
<span class="n">orphanPts</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">extractChimeraInfo</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;orphan&#39;</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">orphanPts</span><span class="p">,</span> <span class="s2">&quot;orphanPts.cgns&quot;</span><span class="p">)</span>
<span class="n">X</span><span class="o">.</span><span class="n">_chimeraInfo</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;extrapolated&#39;</span><span class="p">)</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">extractChimeraInfo</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;cf&gt;1.5&#39;</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="s2">&quot;out.cgns&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<hr class="docutils" />
<section id="overset-grid-connectivity-for-elsa-solver">
<h3>Overset grid connectivity for elsA solver</h3>
<dl class="py function">
<dt class="sig sig-object py" id="Connector.PyTree.setInterpolations">
<span class="sig-prename descclassname"><span class="pre">Connector.PyTree.</span></span><span class="sig-name descname"><span class="pre">setInterpolations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cell'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">double_wall</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">storage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'inverse'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefixFile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sameBase</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'elsA'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nGhostCells</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parallelDatas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cfMax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">30.</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">planarTol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">check</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>This function is specific to elsA solver.
Set the Chimera connectivity (EX points and cell centers to be interpolated, index for donor interpolation cell and interpolation coefficients).
Double wall projection technique is activated if &#8216;double_wall=1&#8217;.
Parameter planarTol can be useful for double wall cases, in the case when double wall surfaces are planar but distant from planarTol to each other.
Parameter &#8216;sameBase=1&#8217; means that donor zones can be found in the same base as the current zone.</p>
<p>parallelDatas=[graph,rank,listOfInterpCells] is defined only in a coupling context. It contains the graph of communication, the rank of the current processor and the list of interpolated cells/faces indices.  graph is a Python dictionary with the following structure : graph[proc1][proc2] gives the list of zones on processeur 1 which intersect with zones on processor 2.
loc=&#8217;cell&#8217; or &#8216;face&#8217; indicates the location of the interpolated points (cell center or face).
Interpolations with location at &#8216;face&#8217; correspond to interpolation for EX points according to elsA solver.</p>
<p>storage can be &#8216;direct&#8217; (interpolation data stored in receptor zones) or &#8216;inverse&#8217; (data stored in donor zones). Value storage=&#8217;direct&#8217; is only valid if Chimera connectivity is read by elsA solver as Chimera connectivity files.</p>
<p>In a distributed mode, the storage must be necessarily &#8216;inverse&#8217;. If the Chimera connectivity is read by elsA directly as CGNS ZoneSubRegion_t nodes, then the storage must be &#8216;inverse&#8217; too.
prefixFile is the prefix for the name of the connectivity files generated for elsA solver (solver=&#8217;elsA&#8217;) or Cassiopee solver (solver=&#8217;Cassiopee&#8217;). If prefixFile is not specified by the user, no Chimera connectivity file is dumped.</p>
<p>nGhostCells is the number of ghost cells that are required by elsA solver when writing connectivity files. Can be greater than 2 only if elsA reads the Chimera connectivity files.
cfMax is a threshold value for a valid extrapolation: if the sum of the extrapolated coefficients is greater than cfMax, then the cell is marked as orphan.</p>
<p>parallelDatas: used to perform setInterpolations in a distributed context : a list of communication information [graph, rank, interpPts], where interpPts is the list of interpolated cells/EX points.</p>
<p>Parameter check is a Boolean which displays the summary of interpolated, extrapolated and orphan points.</p>
<p>Exists also as an in-place function (X._setInterpolations):</p>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/setInterpolationsPT.py">set interpolations  (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - setInterpolation (pyTree) -</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Connector.PyTree</span> <span class="k">as</span> <span class="nn">X</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cylinder</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mf">1.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mi">360</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,(</span><span class="mi">200</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">2</span><span class="p">));</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cylindre1&#39;</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addBC2Zone</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;wall1&#39;</span><span class="p">,</span> <span class="s1">&#39;BCWall&#39;</span><span class="p">,</span> <span class="s1">&#39;jmin&#39;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addBC2Zone</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;ov1&#39;</span><span class="p">,</span> <span class="s1">&#39;BCOverlap&#39;</span><span class="p">,</span> <span class="s1">&#39;jmax&#39;</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cylinder</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mf">1.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mi">360</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,(</span><span class="mi">200</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">2</span><span class="p">));</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cylindre2&#39;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addBC2Zone</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">&#39;wall1&#39;</span><span class="p">,</span> <span class="s1">&#39;BCWall&#39;</span><span class="p">,</span> <span class="s1">&#39;jmin&#39;</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addBC2Zone</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">&#39;ov1&#39;</span><span class="p">,</span> <span class="s1">&#39;BCOverlap&#39;</span><span class="p">,</span> <span class="s1">&#39;jmax&#39;</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="o">-</span><span class="mf">5.</span><span class="p">,</span><span class="o">-</span><span class="mf">7.5</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mf">15.</span><span class="o">/</span><span class="mi">200</span><span class="p">,</span><span class="mf">15.</span><span class="o">/</span><span class="mi">200</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="mi">200</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Corps1&#39;</span><span class="p">,</span> <span class="s1">&#39;Corps2&#39;</span><span class="p">,</span> <span class="s1">&#39;Bgrd&#39;</span><span class="p">])</span>
<span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">connectMatch</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">fillEmptyBCWith</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="s1">&#39;nref&#39;</span><span class="p">,</span><span class="s1">&#39;BCFarfield&#39;</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">applyBCOverlaps</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">setInterpolations</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="n">prefixFile</span><span class="o">=</span><span class="s1">&#39;chimData&#39;</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;out.cgns&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Connector.PyTree.chimeraTransfer">
<span class="sig-prename descclassname"><span class="pre">Connector.PyTree.</span></span><span class="sig-name descname"><span class="pre">chimeraTransfer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">storage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'direct'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cell'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'extended'</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Compute Chimera transfers. This function is compliant with the storage as it is defined for setInterpolations function.</p>
<p>Parameter storage can be &#8216;direct&#8217; or &#8216;inverse&#8217; and must be consistent with the storage computed by setInterpolations</p>
<p>Parameter &#8216;variables&#8217; specifies the variables for which the transfer is applied.</p>
<p>Parameter loc can be &#8216;cell&#8217; or &#8216;face&#8217; to transfer the variables at cell centers or EX points.</p>
<p>Parameter mesh can be &#8216;standard&#8217; or &#8216;extended&#8217;. For elsA simulations, it is mandatory to use mesh=&#8217;extended&#8217; and storage=&#8217;inverse&#8217;.</p>
<p>Exists also as an in-place function (X._chimeraTransfer)</p>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/chimeraTransferPT.py">compute Chimera transfers (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - chimeraTransfer (pyTree) -</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Connector.PyTree</span> <span class="k">as</span> <span class="nn">X</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cylinder</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mf">1.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mi">360</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,(</span><span class="mi">200</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">3</span><span class="p">));</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cylindre1&#39;</span>
<span class="n">C</span><span class="o">.</span><span class="n">_addBC2Zone</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;wall1&#39;</span><span class="p">,</span> <span class="s1">&#39;BCWall&#39;</span><span class="p">,</span> <span class="s1">&#39;jmin&#39;</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">_addBC2Zone</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;ov1&#39;</span><span class="p">,</span> <span class="s1">&#39;BCOverlap&#39;</span><span class="p">,</span> <span class="s1">&#39;jmax&#39;</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cylinder</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mf">1.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mi">360</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,(</span><span class="mi">200</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">3</span><span class="p">));</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cylindre2&#39;</span>
<span class="n">C</span><span class="o">.</span><span class="n">_addBC2Zone</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">&#39;wall1&#39;</span><span class="p">,</span> <span class="s1">&#39;BCWall&#39;</span><span class="p">,</span> <span class="s1">&#39;jmin&#39;</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">_addBC2Zone</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">&#39;ov1&#39;</span><span class="p">,</span> <span class="s1">&#39;BCOverlap&#39;</span><span class="p">,</span> <span class="s1">&#39;jmax&#39;</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="o">-</span><span class="mf">5.</span><span class="p">,</span><span class="o">-</span><span class="mf">7.5</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mf">15.</span><span class="o">/</span><span class="mi">200</span><span class="p">,</span><span class="mf">15.</span><span class="o">/</span><span class="mi">200</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="mi">200</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Corps1&#39;</span><span class="p">,</span><span class="s1">&#39;Corps2&#39;</span><span class="p">,</span><span class="s1">&#39;Bgrd&#39;</span><span class="p">])</span>
<span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">connectMatch</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">_fillEmptyBCWith</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="s1">&#39;nref&#39;</span><span class="p">,</span><span class="s1">&#39;BCFarfield&#39;</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">X</span><span class="o">.</span><span class="n">_applyBCOverlaps</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">setInterpolations</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">storage</span><span class="o">=</span><span class="s1">&#39;direct&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">])):</span>
    <span class="n">C</span><span class="o">.</span><span class="n">_initVars</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="s1">&#39;centers:Density&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">C</span><span class="o">.</span><span class="n">_initVars</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="s1">&#39;centers:MomentumX&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">C</span><span class="o">.</span><span class="n">_initVars</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="s1">&#39;centers:MomentumY&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">C</span><span class="o">.</span><span class="n">_initVars</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="s1">&#39;centers:MomentumZ&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">C</span><span class="o">.</span><span class="n">_initVars</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="s1">&#39;centers:StagnationEnergy&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">chimeraTransfer</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">storage</span><span class="o">=</span><span class="s1">&#39;direct&#39;</span><span class="p">,</span> <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;centers:Density&#39;</span><span class="p">,</span><span class="s1">&#39;centers:MomentumX&#39;</span><span class="p">,</span><span class="s1">&#39;centers:MomentumY&#39;</span><span class="p">,</span><span class="s1">&#39;centers:MomentumZ&#39;</span><span class="p">,</span><span class="s1">&#39;centers:StagnationEnergy&#39;</span><span class="p">])</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Connector.PyTree.chimeraInfo">
<span class="sig-prename descclassname"><span class="pre">Connector.PyTree.</span></span><span class="sig-name descname"><span class="pre">chimeraInfo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'interpolated'</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Set information on Chimera connectivity, i.e. interpolated, extrapolated or orphan cells, donor aspect ratio and ratio between
volume of donor and receptor cells.</p>
<p>This function is compliant with the storage as it is defined for setInterpolations function.</p>
<p>If type=&#8217;interpolated&#8217;, variable &#8216;centers:interpolated&#8217; is created and is equal to 1 for interpolated and extrapolated cells, 0 otherwise.</p>
<p>If type=&#8217;extrapolated&#8217;, variable &#8216;centers:extrapolated&#8217; is created and its value is the sum of the absolute values of coefficients, 0 otherwise.</p>
<p>If type=&#8217;orphan&#8217;, variable &#8216;centers:orphan&#8217; is created and is equal to 1 for orphan cells,  0 otherwise.</p>
<p>If type=&#8217;cellRatio&#8217;, variable &#8216;centers:cellRatio&#8217; is created and is equal to max(volD/volR,volR/volD) for interpolated and extrapolated cells (volR and volD are volume of receptor and donor cells).</p>
<p>If type=&#8217;donorAspect&#8217;, variable &#8216;centers:donorAspect&#8217; is created and is equal to the ratio between the maximum and minimum length of donor cells, and 0 for cells that are not interpolated.</p>
<p>Exists also as an in-place function (X._chimeraInfo)</p>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/chimeraInfoPT.py">set Chimera information (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - chimeraInfo (pyTree) -</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Connector.PyTree</span> <span class="k">as</span> <span class="nn">X</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cylinder</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mf">1.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mi">360</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,(</span><span class="mi">200</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">4</span><span class="p">));</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cylindre1&#39;</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addBC2Zone</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;wall1&#39;</span><span class="p">,</span> <span class="s1">&#39;BCWall&#39;</span><span class="p">,</span> <span class="s1">&#39;jmin&#39;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addBC2Zone</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;ov1&#39;</span><span class="p">,</span> <span class="s1">&#39;BCOverlap&#39;</span><span class="p">,</span> <span class="s1">&#39;jmax&#39;</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cylinder</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mf">1.</span><span class="p">,</span><span class="mf">3.</span><span class="p">,</span><span class="mi">360</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,(</span><span class="mi">200</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">4</span><span class="p">));</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;cylindre2&#39;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addBC2Zone</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">&#39;wall1&#39;</span><span class="p">,</span> <span class="s1">&#39;BCWall&#39;</span><span class="p">,</span> <span class="s1">&#39;jmin&#39;</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addBC2Zone</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">&#39;ov1&#39;</span><span class="p">,</span> <span class="s1">&#39;BCOverlap&#39;</span><span class="p">,</span> <span class="s1">&#39;jmax&#39;</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="o">-</span><span class="mf">5.</span><span class="p">,</span><span class="o">-</span><span class="mf">7.5</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mf">15.</span><span class="o">/</span><span class="mi">200</span><span class="p">,</span><span class="mf">15.</span><span class="o">/</span><span class="mi">200</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="mi">200</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Corps1&#39;</span><span class="p">,</span> <span class="s1">&#39;Corps2&#39;</span><span class="p">,</span> <span class="s1">&#39;Bgrd&#39;</span><span class="p">])</span>
<span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">connectMatch</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">fillEmptyBCWith</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="s1">&#39;nref&#39;</span><span class="p">,</span><span class="s1">&#39;BCFarfield&#39;</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">applyBCOverlaps</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">setInterpolations</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="n">double_wall</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">storage</span><span class="o">=</span><span class="s1">&#39;direct&#39;</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">chimeraInfo</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;interpolated&#39;</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;out.cgns&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<hr class="docutils" />
<section id="immersed-boundary-ibm-pre-processing">
<h3>Immersed boundary (IBM) pre-processing</h3>
<dl class="py function">
<dt class="sig sig-object py" id="Connector.PyTree.setIBCData">
<span class="sig-prename descclassname"><span class="pre">Connector.PyTree.</span></span><span class="sig-name descname"><span class="pre">setIBCData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">aR</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aD</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">penalty</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nature</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'lagrangian'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'nodes'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">storage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'direct'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">he</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Compute and store IBM information (donor and receptor points, interpolation type, interpolation coefficients, coordinates of corrected, wall and interpolated points) given receptors defined by aR,
donor zones given by aD.</p>
<ul class="simple">
<li><p>If storage=&#8217;direct&#8217;, then aR with interpolation data stored in receptor zones are returned, and if storage=&#8217;inverse&#8217;, then aD with interpolation data stored in donor zones are returned.</p></li>
<li><p>Donor zones can be structured or unstructured TETRA. receptor zones can be structured or unstructured ;</p></li>
<li><p>Interpolation order can be 2, 3 or 5 for structured donor zones, only order=2 for unstructured donor zones is performed ;</p></li>
<li><p>Parameter loc can &#8216;nodes&#8217; or &#8216;centers&#8217;, meaning that receptor points are zone nodes or centers ;</p></li>
<li><p>penalty=1 means that a candidate donor cell located at a zone border is penalized against interior candidate cell ;</p></li>
<li><p>nature=0 means that a candidate donor cell containing a blanked point(cellN=0) is not valid. If nature=1 all the nodes of the candidate donor cell must be cellN=1 to be valid ;</p></li>
<li><p>Interpolation data are stored as a ZoneSubRegion_t node, stored under the donor or receptor zone node depending of the storage ;</p></li>
<li><p>aR must contain information about distances and normals to bodies, defined by &#8216;TurbulentDistance&#8217;,&#8217;gradxTurbulentDistance&#8217;,&#8217;gradyTurbulentDistance&#8217; and &#8216;gradzTurbulentDistance&#8217;, located at nodes or cell centers ;</p></li>
<li><p>Corrected points are defined in aR as points with cellN=2, located at nodes or cell centers ;</p></li>
<li><p>Parameter he is a constant, meaning that the interpolated points are pushed away of a distance he from the IBC points if these are external to the bodies ;</p></li>
<li><p>Parameter hi is a constant. If hi=0., then the interpolated points are mirror points of IBC points. If hi&gt;0., then these mirror points are then pushed away of hi from their initial position ;</p></li>
<li><p>hi and he can be defined as a field (located at nodes or centers) for any point.</p></li>
</ul>
<blockquote>
<div><p><em>Example of use:</em></p>
</div></blockquote>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/setIBCDataPT.py">set IBM data in the pyTree (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - setIBCData (pyTree) -</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Connector.PyTree</span> <span class="k">as</span> <span class="nn">X</span>
<span class="kn">import</span> <span class="nn">Post.PyTree</span> <span class="k">as</span> <span class="nn">P</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">N</span>
<span class="kn">import</span> <span class="nn">Dist2Walls.PyTree</span> <span class="k">as</span> <span class="nn">DTW</span>
<span class="kn">import</span> <span class="nn">Transform.PyTree</span> <span class="k">as</span> <span class="nn">T</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),(</span><span class="mf">0.01</span><span class="p">,</span><span class="mf">0.01</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">201</span><span class="p">,</span><span class="mi">201</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cylinder</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2Tetra</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="n">s</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="n">s</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">exteriorFaces</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Base&#39;</span><span class="p">,</span><span class="n">a</span><span class="p">])</span>
<span class="c1"># Blanking</span>
<span class="n">bodies</span> <span class="o">=</span> <span class="p">[[</span><span class="n">s</span><span class="p">]]</span>
<span class="n">BM</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]],</span><span class="n">N</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">blankCells</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">bodies</span><span class="p">,</span><span class="n">BM</span><span class="p">,</span><span class="n">blankingType</span><span class="o">=</span><span class="s1">&#39;center_in&#39;</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">setHoleInterpolatedPoints</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">depth</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
<span class="c1"># Dist2Walls</span>
<span class="n">DTW</span><span class="o">.</span><span class="n">_distance2Walls</span><span class="p">(</span><span class="n">t</span><span class="p">,[</span><span class="n">s</span><span class="p">],</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ortho&#39;</span><span class="p">,</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;centers&#39;</span><span class="p">,</span><span class="n">signed</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">center2Node</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="s1">&#39;centers:TurbulentDistance&#39;</span><span class="p">)</span>
<span class="c1"># Gradient de distance localise en centres =&gt; normales</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">computeGrad</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;TurbulentDistance&#39;</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">setIBCData</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;centers&#39;</span><span class="p">,</span> <span class="n">storage</span><span class="o">=</span><span class="s1">&#39;direct&#39;</span><span class="p">,</span><span class="n">hi</span><span class="o">=</span><span class="mf">0.03</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;out.cgns&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Connector.ToolboxIBM.prepareIBMData_legacy">
<span class="sig-prename descclassname"><span class="pre">Connector.ToolboxIBM.</span></span><span class="sig-name descname"><span class="pre">prepareIBMData_legacy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">DEPTH</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'centers'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frontType</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Compute and store all the information required for IBM computations.
For Euler computations, corrected points are inside body, for viscous computations,
corrected points are outside body.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> (<em>pyTree</em>) &#8211; pyTree defining the computational domain as a structured mesh</p></li>
<li><p><strong>tb</strong> (<em>pyTree</em>) &#8211; pyTree defining the obstacles. Each obstacle must be defined in a CGNS basis as a surface closed mesh, whose normals must be oriented towards
the fluid region</p></li>
<li><p><strong>DEPTH</strong> (<em>integer</em>) &#8211; number of layers of IBM corrected points (usually 2 meaning 2 ghost cells are required)</p></li>
<li><p><strong>loc</strong> (<em>string</em>) &#8211; location of IBM points: at nodes if loc=&#8217;nodes&#8217; or at cell centers if loc=&#8217;centers&#8217; (&#8216;centers&#8217;default)</p></li>
<li><p><strong>frontType</strong> (<em>integer</em><em> [</em><em>0-2</em><em>]</em>) &#8211; 0: constant distance front, 1: minimum distance front, 2: adapted distance front</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>t, tc</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pyTree</p>
</dd>
</dl>
<p>The problem dimension (2 or 3D) and the equation model (Euler, Navier-Stokes or RANS) are required in tb.</p>
<p>Output datas are:</p>
<ul class="simple">
<li><p>the pyTree t with a &#8216;cellN&#8217; field located at nodes or centers, marking as computed/updated/blanked points for the solver (cellN=1/2/0).</p></li>
<li><p>a donor pyTree tc storing all the information required to transfer then the solution at cellN=2 points:</p></li>
</ul>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/prepareIBMDataPT.py">compute the IBM preprocessing (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - prepareIBMData_legacy (pyTree) -</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Connector.ToolboxIBM</span> <span class="k">as</span> <span class="nn">IBM</span>
<span class="kn">import</span> <span class="nn">Post.PyTree</span> <span class="k">as</span> <span class="nn">P</span>
<span class="kn">import</span> <span class="nn">Geom.PyTree</span> <span class="k">as</span> <span class="nn">D</span>
<span class="kn">import</span> <span class="nn">Dist2Walls.PyTree</span> <span class="k">as</span> <span class="nn">DTW</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">51</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)),(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">))</span>
<span class="n">body</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">sphere</span><span class="p">((</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mf">0.1</span><span class="p">,</span><span class="n">N</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Base&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">])</span>
<span class="n">tb</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Base&#39;</span><span class="p">,</span> <span class="n">body</span><span class="p">])</span>
<span class="n">tb</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="s1">&#39;EquationDimension&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">tb</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="s1">&#39;GoverningEquations&#39;</span><span class="p">,</span> <span class="s1">&#39;NSTurbulent&#39;</span><span class="p">)</span>
<span class="n">DTW</span><span class="o">.</span><span class="n">_distance2Walls</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">bodies</span><span class="o">=</span><span class="n">tb</span><span class="p">,</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;centers&#39;</span><span class="p">,</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ortho&#39;</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">computeGrad</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="s1">&#39;centers:TurbulentDistance&#39;</span><span class="p">)</span>
<span class="n">t</span><span class="p">,</span><span class="n">tc</span><span class="o">=</span><span class="n">IBM</span><span class="o">.</span><span class="n">prepareIBMData_legacy</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">tb</span><span class="p">,</span> <span class="n">DEPTH</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">frontType</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="s1">&#39;t.cgns&#39;</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="s1">&#39;tc.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>requires Connector.ToolboxIBM.py module.</p>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Connector.ToolboxIBM.extractIBMInfo">
<span class="sig-prename descclassname"><span class="pre">Connector.ToolboxIBM.</span></span><span class="sig-name descname"><span class="pre">extractIBMInfo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Extract the IBM particular points once the IBM data is computed and stored in a pyTree. These points are the IBM points that are marked
as updated points for the IBM approach and the corresponding wall and interpolated (in fluid) points.</p>
<p>If information is stored in the donor pyTree tc, then a=tc, else a must define the receptor pyTree t.</p>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/extractIBMInfoPT.py">extract all the IBM points (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - prepareIBMData_legacy (pyTree) -</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Connector.ToolboxIBM</span> <span class="k">as</span> <span class="nn">IBM</span>
<span class="kn">import</span> <span class="nn">Post.PyTree</span> <span class="k">as</span> <span class="nn">P</span>
<span class="kn">import</span> <span class="nn">Geom.PyTree</span> <span class="k">as</span> <span class="nn">D</span>
<span class="kn">import</span> <span class="nn">Dist2Walls.PyTree</span> <span class="k">as</span> <span class="nn">DTW</span>

<span class="n">N</span> <span class="o">=</span> <span class="mi">21</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)),(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">))</span>
<span class="n">body</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">sphere</span><span class="p">((</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mf">0.1</span><span class="p">,</span><span class="n">N</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Base&#39;</span><span class="p">,</span><span class="n">a</span><span class="p">])</span>
<span class="n">tb</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Base&#39;</span><span class="p">,</span><span class="n">body</span><span class="p">])</span>
<span class="n">tb</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="s1">&#39;EquationDimension&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">tb</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addState</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="s1">&#39;GoverningEquations&#39;</span><span class="p">,</span> <span class="s1">&#39;NSTurbulent&#39;</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">DTW</span><span class="o">.</span><span class="n">distance2Walls</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">bodies</span><span class="o">=</span><span class="n">tb</span><span class="p">,</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;centers&#39;</span><span class="p">,</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ortho&#39;</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">computeGrad</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="s1">&#39;centers:TurbulentDistance&#39;</span><span class="p">)</span>
<span class="n">t</span><span class="p">,</span><span class="n">tc</span><span class="o">=</span><span class="n">IBM</span><span class="o">.</span><span class="n">prepareIBMData_legacy</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">tb</span><span class="p">,</span> <span class="n">DEPTH</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">IBM</span><span class="o">.</span><span class="n">extractIBMInfo</span><span class="p">(</span><span class="n">tc</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">res</span><span class="p">,</span><span class="s2">&quot;res.cgns&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>requires Connector.ToolboxIBM.py module.</p>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Connector.ToolboxIBM.extractIBMWallFields">
<span class="sig-prename descclassname"><span class="pre">Connector.ToolboxIBM.</span></span><span class="sig-name descname"><span class="pre">extractIBMWallFields</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Extract the solution at walls. If IBM data is stored in donor pyTree tc, then a must be tc, else a is the pyTree t.</p>
<p>If tb is None, then tw is the cloud of wall points. If tb is a triangular surface mesh, then the solution extracted at cloud points is interpolated
on the vertices of the triangular mesh. a must contain the fields in the ZoneSubRegions of name prefixed by &#8216;IBCD&#8217;.</p>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/extractIBMWallFieldsPT.py">Extract the solution on the wall  (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - extractionIBM a la paroi (pyTree) -</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Connector.PyTree</span> <span class="k">as</span> <span class="nn">X</span>
<span class="kn">import</span> <span class="nn">Geom.PyTree</span> <span class="k">as</span> <span class="nn">D</span>
<span class="kn">import</span> <span class="nn">Post.PyTree</span> <span class="k">as</span> <span class="nn">P</span>
<span class="kn">import</span> <span class="nn">Dist2Walls.PyTree</span> <span class="k">as</span> <span class="nn">DTW</span>
<span class="kn">import</span> <span class="nn">Transform.PyTree</span> <span class="k">as</span> <span class="nn">T</span>
<span class="kn">import</span> <span class="nn">Initiator.PyTree</span> <span class="k">as</span> <span class="nn">I</span>
<span class="kn">import</span> <span class="nn">Converter.Internal</span> <span class="k">as</span> <span class="nn">Internal</span>
<span class="kn">import</span> <span class="nn">Connector.ToolboxIBM</span> <span class="k">as</span> <span class="nn">IBM</span>
<span class="kn">import</span> <span class="nn">KCore.test</span> <span class="k">as</span> <span class="nn">test</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="n">N</span> <span class="o">=</span> <span class="mi">41</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)),(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">))</span>
<span class="n">xm</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">N</span><span class="o">/</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">sphere</span><span class="p">((</span><span class="n">xm</span><span class="p">,</span><span class="n">xm</span><span class="p">,</span><span class="n">xm</span><span class="p">),</span><span class="mf">0.1</span><span class="p">,</span><span class="n">N</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2Tetra</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="n">s</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Base&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">])</span>

<span class="c1"># Blanking</span>
<span class="n">bodies</span> <span class="o">=</span> <span class="p">[[</span><span class="n">s</span><span class="p">]]</span>
<span class="n">BM</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">]],</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">blankCells</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">bodies</span><span class="p">,</span><span class="n">BM</span><span class="p">,</span><span class="n">blankingType</span><span class="o">=</span><span class="s1">&#39;center_in&#39;</span><span class="p">)</span>
<span class="n">X</span><span class="o">.</span><span class="n">_setHoleInterpolatedPoints</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">depth</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
<span class="c1"># Dist2Walls</span>
<span class="n">DTW</span><span class="o">.</span><span class="n">_distance2Walls</span><span class="p">(</span><span class="n">t</span><span class="p">,[</span><span class="n">s</span><span class="p">],</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ortho&#39;</span><span class="p">,</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;centers&#39;</span><span class="p">,</span><span class="n">signed</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">center2Node</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="s1">&#39;centers:TurbulentDistance&#39;</span><span class="p">)</span>
<span class="c1"># Gradient de distance localise en centres =&gt; normales</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">computeGrad</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;TurbulentDistance&#39;</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">_initVars</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="s2">&quot;centers:Density&quot;</span><span class="p">,</span><span class="mf">1.</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">_initVars</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="s2">&quot;centers:VelocityX&quot;</span><span class="p">,</span><span class="mf">0.2</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">_initVars</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="s2">&quot;centers:VelocityY&quot;</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">_initVars</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="s2">&quot;centers:VelocityZ&quot;</span><span class="p">,</span><span class="mf">0.</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">_initVars</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="s2">&quot;centers:Temperature&quot;</span><span class="p">,</span><span class="mf">1.</span><span class="p">)</span>
<span class="n">tc</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">node2Center</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

<span class="n">tb</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Base&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">])</span>
<span class="n">C</span><span class="o">.</span><span class="n">_addState</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="s1">&#39;EquationDimension&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">_addState</span><span class="p">(</span><span class="n">tb</span><span class="p">,</span> <span class="s1">&#39;GoverningEquations&#39;</span><span class="p">,</span> <span class="s1">&#39;NSTurbulent&#39;</span><span class="p">)</span>

<span class="n">X</span><span class="o">.</span><span class="n">_setIBCData</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">tc</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;centers&#39;</span><span class="p">,</span> <span class="n">storage</span><span class="o">=</span><span class="s1">&#39;inverse&#39;</span><span class="p">,</span> <span class="n">bcType</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1">#test avec arbre tc compact</span>
<span class="nb">vars</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Density&#39;</span><span class="p">,</span><span class="s1">&#39;VelocityX&#39;</span><span class="p">,</span><span class="s1">&#39;VelocityY&#39;</span><span class="p">,</span><span class="s1">&#39;VelocityZ&#39;</span><span class="p">,</span><span class="s1">&#39;Temperature&#39;</span><span class="p">]</span>

<span class="n">zones</span> <span class="o">=</span> <span class="n">Internal</span><span class="o">.</span><span class="n">getNodesFromType2</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;Zone_t&#39;</span><span class="p">)</span>
<span class="n">X</span><span class="o">.</span><span class="n">miseAPlatDonorTree__</span><span class="p">(</span><span class="n">zones</span><span class="p">,</span> <span class="n">tc</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="c1"># attention compact=0 car t n est pas compacte</span>
<span class="n">X</span><span class="o">.</span><span class="n">_setInterpTransfers</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">tc</span><span class="p">,</span> <span class="n">bcType</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">varType</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">variablesIBC</span><span class="o">=</span><span class="nb">vars</span><span class="p">,</span><span class="n">compact</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">compactD</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">IBM</span><span class="o">.</span><span class="n">extractIBMWallFields</span><span class="p">(</span><span class="n">tc</span><span class="p">,</span> <span class="n">tb</span><span class="o">=</span><span class="n">tb</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="s2">&quot;out.cgns&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>requires Connector.ToolboxIBM.py module.</p>
</div>
</dd></dl>

</section>
<hr class="docutils" />
<section id="overset-and-immersed-boundary-transfers-with-pytrees">
<h3>Overset and Immersed Boundary transfers with pyTrees</h3>
<blockquote>
<div><blockquote>
<div><p>The following function enables to update the solution at some points, marked as interpolated for overset and IBM approaches.</p>
</div></blockquote>
<dl class="py function">
<dt class="sig sig-object py" id="Connector.PyTree.setInterpTransfers">
<span class="sig-prename descclassname"><span class="pre">Connector.PyTree.</span></span><span class="sig-name descname"><span class="pre">setInterpTransfers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">aR</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">topTreeD</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variables</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">variablesIBC</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['Density',</span> <span class="pre">'MomentumX',</span> <span class="pre">'MomentumY',</span> <span class="pre">'MomentumZ',</span> <span class="pre">'EnergyStagnationDensity']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bcType</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">varType</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">storage</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'unknown'</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>General transfers from a set of donor zones defined by topTreeD to receptor zones defined in aR.</p>
<p>Both Chimera and IBM transfers can be applied and are identified by the prefix name of the ZoneSubRegion node
created when computing the overset or IBM interpolation data.</p>
<p>Parameter variables is the list of variable names that are transfered by Chimera interpolation.</p>
<p>Parameter variablesIBC defines the name of the 5 variables used for IBM transfers.</p>
<p>Parameter bcType can be 0 or 1 (see table below for details).</p>
<p>Parameter varType enables to define the meaning of variablesIBC, if their name is not standard (see table below for more details).</p>
<p>Parameter storage enables to define how the information is stored (see table below).</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Parameter value</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>bcType=0</p></td>
<td><p>IBM transfers model slip conditions</p></td>
</tr>
<tr class="row-odd"><td><p>bcType=1</p></td>
<td><p>IBM transfers model no-slip conditions</p></td>
</tr>
<tr class="row-even"><td><p>varType=1</p></td>
<td><p>Density,MomentumX,MomentumY,MomentumZ,EnergyStagnationDensity</p></td>
</tr>
<tr class="row-odd"><td><p>varType=2</p></td>
<td><p>Density,VelocityX,VelocityY,VelocityZ,Temperature</p></td>
</tr>
<tr class="row-even"><td><p>varType=3</p></td>
<td><p>Density,VelocityX,VelocityY,VelocityZ,Pressure</p></td>
</tr>
<tr class="row-odd"><td><p>storage=0</p></td>
<td><p>Interpolation data is stored in receptor zones aR</p></td>
</tr>
<tr class="row-even"><td><p>storage=1</p></td>
<td><p>Interpolation data is stored in donor zones topTreeD</p></td>
</tr>
<tr class="row-odd"><td><p>storage=-1</p></td>
<td><p>Interpolation data storage is unknown or can be stored in donor and receptor zones.</p></td>
</tr>
<tr class="row-even"><td><p>extract=1</p></td>
<td><p>Wall fields are stored in zone subregions (density and pressure, utau and yplus if wall law is applied).</p></td>
</tr>
</tbody>
</table>
<p>Exists also as an in-place function (X._setInterpTransfers):
Exists also as a parallel distributed function (X.Mpi._setInterpTransfers)</p>
<blockquote>
<div><p><em>Example of use:</em></p>
</div></blockquote>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Connector/setInterpTransfersPT.py">Transfers the solution from donor zones to receptor zones (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - setInterpTransfers (pyTree) -</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Connector.PyTree</span> <span class="k">as</span> <span class="nn">X</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cylinder</span><span class="p">(</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">360</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cylinder</span><span class="p">(</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">160</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addBC2Zone</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;wall&#39;</span><span class="p">,</span> <span class="s1">&#39;BCWall&#39;</span><span class="p">,</span> <span class="s1">&#39;jmin&#39;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addBC2Zone</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;match&#39;</span><span class="p">,</span> <span class="s1">&#39;BCMatch&#39;</span><span class="p">,</span> <span class="s1">&#39;imin&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="s1">&#39;imax&#39;</span><span class="p">,</span> <span class="n">trirac</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addBC2Zone</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;match&#39;</span><span class="p">,</span> <span class="s1">&#39;BCMatch&#39;</span><span class="p">,</span> <span class="s1">&#39;imax&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="s1">&#39;imin&#39;</span><span class="p">,</span> <span class="n">trirac</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addBC2Zone</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">&#39;wall&#39;</span><span class="p">,</span> <span class="s1">&#39;BCWall&#39;</span><span class="p">,</span> <span class="s1">&#39;jmin&#39;</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addBC2Zone</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">&#39;overlap&#39;</span><span class="p">,</span> <span class="s1">&#39;BCOverlap&#39;</span><span class="p">,</span> <span class="s1">&#39;imin&#39;</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">addBC2Zone</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s1">&#39;overlap&#39;</span><span class="p">,</span> <span class="s1">&#39;BCOverlap&#39;</span><span class="p">,</span> <span class="s1">&#39;imax&#39;</span><span class="p">)</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Base&#39;</span><span class="p">]);</span> <span class="n">t1</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">];</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Base&#39;</span><span class="p">]);</span> <span class="n">t2</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">fillEmptyBCWith</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="s1">&#39;nref&#39;</span><span class="p">,</span> <span class="s1">&#39;BCFarfield&#39;</span><span class="p">)</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">fillEmptyBCWith</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;nref&#39;</span><span class="p">,</span> <span class="s1">&#39;BCFarfield&#39;</span><span class="p">)</span>

<span class="n">t1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">initVars</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{Density}</span><span class="s1">= 1.&#39;</span><span class="p">)</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">initVars</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{Density}</span><span class="s1">=-1.&#39;</span><span class="p">)</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">node2Center</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;Density&#39;</span><span class="p">])</span>

<span class="n">t2</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">applyBCOverlaps</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">setInterpData</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">double_wall</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;centers&#39;</span><span class="p">,</span>
                     <span class="n">storage</span><span class="o">=</span><span class="s1">&#39;inverse&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">setInterpTransfers</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">t1</span><span class="p">,</span> <span class="n">variables</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Density&#39;</span><span class="p">])</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div></blockquote>
<hr class="docutils" />
<div class="toctree-wrapper compound">
</div>
</section>
</section>
<section id="index">
<h2>Index</h2>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="#">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Connector: Grid connectivity module</a><ul>
<li><a class="reference internal" href="#preamble">Preamble</a></li>
<li><a class="reference internal" href="#list-of-functions">List of functions</a></li>
<li><a class="reference internal" href="#contents">Contents</a></li>
<li><a class="reference internal" href="#index">Index</a></li>
</ul>
</li>
</ul>

  </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><a  href="Connector.pdf" target="_self">Download pdf version</a>
<p></p>
<head>
<style>
#myBtn {
  display: none;
  position: fixed;
  bottom: 20px;
  right: 30px;
  z-index: 99;
  border: none;
  outline: none;
  background-color: #282a35;
  cursor: pointer;
  padding: 15px;
  border-radius: 10px;
}

#myBtn:hover {
  background-color: rgb(26,85,85);
}

#myImg:hover {
  opacity: 50%;
}

</style>
</head>

<button onclick="topFunction()" id="myBtn" title="Go to top"><img src="./_static/icon.png" width="20" height="20"></button>

<script>
const targetDiv = document.getElementsByClassName('sphinxsidebarwrapper')[0];

const link = document.createElement('a');
link.href = "../index.html";

const newImage = document.createElement('img');
newImage.src = '../Images/CassiopeeLogo.png';
newImage.id = 'myImg';
newImage.style.width = '80%';
newImage.style.height = 'auto';
newImage.style.border = 'none';
newImage.style.borderRadius = '0px';
newImage.style.marginLeft = '18px';
newImage.style.marginBottom = '50px';

// Append the image to the div
link.appendChild(newImage);
targetDiv.prepend(link);

// When the user scrolls down 20px from the top of the document, show the button
window.onscroll = scrollFunction;
function scrollFunction() {
    if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
        document.getElementById("myBtn").style.display = "block";
    } else {
        document.getElementById("myBtn").style.display = "none";
    }
}

// When the user clicks on the button, scroll to the top of the document
function topFunction() {
    document.body.scrollTop = 0;
    document.documentElement.scrollTop = 0;
}

// When the window is too small, hide the sidebar
window.onresize = resizeFunction;
window.onload = resizeFunction;
function resizeFunction() {
  var bodyWidth = document.bodyWidth;
  if (window.outerWidth < 1000) {
        document.getElementsByClassName("sphinxsidebar")[0].style.visibility = "hidden";
        document.getElementById("myBtn").style.visibility = "visible";
        document.getElementsByClassName("body")[0].style.marginLeft = "-170px";
        document.getElementsByClassName("body")[0].style.maxWidth = "135%";
        document.getElementsByClassName("body")[0].style.paddingLeft = "30px";
    } else {
        document.getElementsByClassName("sphinxsidebar")[0].style.visibility = "visible";
        document.getElementsByClassName("body")[0].style.marginLeft = "130px";
        document.getElementsByClassName("body")[0].style.maxWidth = "80%";
        document.getElementsByClassName("body")[0].style.paddingLeft = "0px";
    }
}

</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">Connector 4.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Connector: Grid connectivity module</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    </div>
  </body>
</html>