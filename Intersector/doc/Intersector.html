<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>Intersector: Mesh intersection module</title>
    <link href="Cassiopee.css" rel="stylesheet" type="text/css">
    <link rel="icon" type="image/png" href="iconc.png"> </link>
    <script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');ga('create', 'UA-31301505-1', 'auto');ga('send', 'pageview');</script>
  </head>

  <body>
    <h1>Intersector: Mesh-Intersection-Based Services</h1>
    <h2>Version: 2.5 (20/09/2017)</h2>
    <h2>Author: Onera</h2>
    <h2><a href="Latex/Intersector.pdf" target="_self"><img src="pdf_logo.gif" alt="Download pdf version."></a></h2>
  <HR>

    <h3>Preamble</h3>

    This module provides pre ans post processing services relying on mesh-intersection computations on arbitrary polyhedral meshes. <br>
    It also gives auxiliary functions that transform topologically and geometrically polyhedral meshes which are useful in the process of mesh generation by intersection.<br><br>
    
    A mesh can be stored as an array (as defined in the Converter documentation)
    or in a zone node of a CGNS/python tree (pyTree).<br><br>

    This module is part of Cassiopee.<br><br>

    When using the array interface, import the Intersector module:<br><br>
    <div class="code">
      import Intersector as XOR (array version)<br>
      or<br>
      import Intersector.PyTree as XOR (PyTree version)
    </div><br>
    
    <p></p>
    <h3>Main Functions</h3>
    <p></p>

    <strong>XOR.conformUnstr</strong>: conformizes a TRI or BAR soup (i.e. a set of elements not necessarily connected as a mesh) by detecting and solving all the collisions between elements. 
    <br>Colliding elements are cut to get a conformal set. Mixed type BAR/TRI are not handled.
    
    <table border="2" align="center" cellpadding="3" cellspacing="1" style="font-size:90%">
    <tr>
    <td><strong>Parameter</strong> </td>
    <td><strong>Meaning</strong></td>
    </tr>
    <tr><td> s1</td>
    <td>input mesh (BAR or TRI). If s2 is 'None' self-intersections are solved over s1.</td></tr>
    <tr><td> [s2]</td>
    <td>optional : conformize s1 taking into account collisions that might occur with s2</td></tr>
    <tr><td> tol</td>
    <td> merging tolerance when points (exisiting or computed by intersections) are too close.</td></tr>
    <tr><td> left_or_right</td>
    <td> Tells the function what to ouput : the transformed s1 (left operand), s2(right operand) or both.</td></tr>
    <tr><td> itermax</td>
    <td> Number of intersection/merging iterations. 10 is the default value.</td></tr>
    </table><br>
    
    <table border="2" align="center" cellpadding="3" cellspacing="1" style="font-size:90%">
    <tr>
    <td><strong>Parameter values</strong> </td>
    <td><strong>Meaning</strong></td>
    </tr>
    <tr><td> tol>0. </td>
    <td> use the input value as an absolute merging tolerance.</td></tr>
    <tr><td> tol=0. (default)</td>
    <td> Computes the tolerance as 5% of the overall min edge length.</td></tr>
    <tr><td> tol<0. </td>
    <td> Consider this input value (must be between 0. and 1.) as a ratio to apply to the min edge length to get the tolerance.</td></tr>
    <tr><td> left_or_right=0</td>
    <td> Output s1</td></tr>
    <tr><td> left_or_right=1</td>
    <td> Output s2.</td></tr>
    <tr><td> left_or_right=2 (default)</td>
    <td> Output both s1 and s2.</td></tr>
    </table><br>
    
    <i>Tip: set itermax to 1. to improve speed and the Delaunay kernel robustness. The result might have poorer quality triangles though.</i><br><br>
    <div class="code">
      B = XOR.conformUnstr(s1, s2=None, tol=0., left_or_right=2, itermax=10)
    </div>
    <br>prerequisite : input surfaces must be oriented consistently and outwardly (make a call to Transform.reorderAll before)
    <br><br><em>Example of use: </em><a href="Examples/Intersector/conformUnstr.py"> conformize a TRI or BAR soup (array)</a>,
    <a href="Examples/Intersector/conformUnstrPT.py"> conformize a TRI or BAR soup (pyTree)</a>.<br><br>

    <strong>XOR.booleanUnion</strong>: performs a boolean union of two TRI-surfaces:
    <div class="code">
      b = XOR.booleanUnion(a1, a2, tol=0.)
    </div>
    <br>prerequisite : input surfaces must be oriented consistently and outwardly (make a call to Transform.reorderAll before)
    <br><br><em>Example of use: </em><a href="Examples/Intersector/booleanUnion.py"> union of two surfaces (array)</a>,
    <a href="Examples/Intersector/booleanUnionPT.py"> union of two surfaces (pyTree)</a>.<br><br>

    <strong>XOR.booleanMinus</strong>: performs a boolean difference of two TRI-surfaces:
    <div class="code">
      b = XOR.booleanMinus(a1, a2, tol=0.)
    </div>
    <br>prerequisite : input surfaces must be oriented consistently and outwardly (make a call to Transform.reorderAll before)
    <br><br><em>Example of use: </em><a href="Examples/Intersector/booleanMinus.py"> difference of two surfaces (array)</a>,
    <a href="Examples/Intersector/booleanMinusPT.py"> difference of two surfaces (pyTree)</a>.<br><br>

    <strong>XOR.booleanIntersection</strong>: performs a boolean intersection of two TRI-surfaces:
    <div class="code">
      b = XOR.booleanIntersection(a1, a2, tol=0.)
    </div>
    <br>prerequisite : input surfaces must be oriented consistently and outwardly (use Transform.reorderAll)
    <br><br><em>Example of use: </em><a href="Examples/Intersector/booleanIntersection.py"> intersection of two surfaces (array)</a>,
    <a href="Examples/Intersector/booleanIntersectionPT.py"> intersection of two surfaces (pyTree)</a>.<br><br>

    <strong>XOR.intersection</strong>: returns the 'BAR' contour defining the intersection between two TRI-surfaces:
    <div class="code">
      b = XOR.intersection(a1, a2, tol=0.)
    </div>
    <em>Example of use: </em><a href="Examples/Intersector/intersection.py"> intersection contour of two surfaces (array)</a>,
    <a href="Examples/Intersector/intersectionPT.py"> intersection contour of two surfaces (pyTree)</a>.<br><br>
    
    <strong>XOR.XcellN</strong>: computes the cell nature field of a background mesh (bgm) in an overset configuration : similarily to the blanCells functions, the input maskMesh are volume meshes that hide bgm.
    The computed celln is accurate, giving a floating value ranging from 0. (fully masked) to 1. (fully visible).<br>
    The input grids (bgm and makingMesh) are defined by coords located at nodes as a list of arrays.<br><br>

    <i>Warning: location of celln must be located at centers.</i><br>
    <i>Warning: In order to set the celln to 0. inside blanking bodies, you need to create BCWall type boundaries on the body faces.</i><br><br>
    <div class="code">
    celln = XOR.XcellN(bgm, celln, maskMesh)
    </div><br>
    <em> Example of use: </em><a href="Examples/Intersector/XcellNPT.py"> computing the cellN (pyTree)</a>.<br><br>
    
    <p></p>
    <h3>Auxiliary Functions</h3>
    <p></p>
    
    <strong>XOR.triangulateExteriorFaces</strong>: Triangulates any external polygon on a polyhedral mesh (NGON format) 
    <div class="code">
      b = XOR.triangulateExteriorFaces(NGON3Dmesh)
    </div>
    <em>Example of use: </em><a href="Examples/Intersector/triangulateExteriorFaces.py"> array version</a>,
    <a href="Examples/Intersector/triangulateExteriorFacesPT.py"> pyTree version</a>.<br><br>
    
    <strong>XOR.convexifyFaces</strong>: Makes a convex decomposition of any concave polygon (NGON format) 
    <div class="code">
      b = XOR.convexifyFaces(NGON3Dmesh)
    </div>
    <em>Example of use: </em><a href="Examples/Intersector/convexifyFaces.py"> array version</a>,
    <a href="Examples/Intersector/convexifyFacesPT.py"> pyTree version</a>.<br><br>

  </body>
</html>
