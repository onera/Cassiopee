
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="ASCII" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Intersector: Mesh-Intersection-Based Services &#8212; Intersector 4.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/classic.css" />
    
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">Intersector 4.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Intersector: Mesh-Intersection-Based Services</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="intersector-mesh-intersection-based-services">
<h1>Intersector: Mesh-Intersection-Based Services</h1>
<section id="preamble">
<h2>Preamble</h2>
<p>This module provides pre and post processing services relying on mesh-intersection computations on arbitrary polyhedral meshes.</p>
<p>It also gives auxiliary functions that transform topologically and geometrically polyhedral meshes which are useful in the process of mesh generation by intersection.</p>
<p>A mesh can be stored as an array (as defined in the Converter documentation)
or in a zone node of a CGNS/python tree (pyTree).</p>
<p>This module is part of Cassiopee, a free open-source pre- and post-processor for CFD simulations.</p>
<p>For use with the array interface, you have to import Intersector module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">Intersector</span> <span class="k">as</span> <span class="nn">XOR</span>
</pre></div>
</div>
<p>For use with the pyTree interface:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>
</pre></div>
</div>
<span class="target" id="module-Intersector"></span></section>
<section id="list-of-functions">
<h2>List of functions</h2>
<p><strong>&#8211; Main Functions</strong></p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#Intersector.conformUnstr" title="Intersector.conformUnstr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.conformUnstr</span></code></a></p></td>
<td><p>Conformizes a1 (optionally with a2).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Intersector.booleanUnion" title="Intersector.booleanUnion"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.booleanUnion</span></code></a></p></td>
<td><p>Computes the union between two closed-surface or two volume meshes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Intersector.booleanIntersection" title="Intersector.booleanIntersection"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.booleanIntersection</span></code></a></p></td>
<td><p>Computes the intersection between two closed-surface or two volume meshes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Intersector.booleanMinus" title="Intersector.booleanMinus"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.booleanMinus</span></code></a></p></td>
<td><p>Computes the difference between two closed-surface or two volume meshes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Intersector.diffSurf" title="Intersector.diffSurf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.diffSurf</span></code></a></p></td>
<td><p>Computes the difference between a volume mesh and a surface mesh.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Intersector.intersection" title="Intersector.intersection"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.intersection</span></code></a></p></td>
<td><p>Computes the intersection trace (a polyline) between two input closed surfaces.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Intersector.PyTree.XcellN" title="Intersector.PyTree.XcellN"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.PyTree.XcellN</span></code></a></p></td>
<td><p>Computes the weight coefficients of visibility for overset grid configurations as a field called xcelln, for both surface and volume mesh of any kind.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Intersector.adaptCells" title="Intersector.adaptCells"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.adaptCells</span></code></a></p></td>
<td><p>Adapts an unstructured mesh a with repsect to a sensor.</p></td>
</tr>
</tbody>
</table>
<p><strong>&#8211; Collision predicates</strong></p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#Intersector.getOverlappingFaces" title="Intersector.getOverlappingFaces"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.getOverlappingFaces</span></code></a></p></td>
<td><p>Returns the list of polygons in a1 and a2 that are overlapping.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Intersector.getCollidingCells" title="Intersector.getCollidingCells"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.getCollidingCells</span></code></a></p></td>
<td><p>Returns the list of cells in a1 and a2 that are colliding.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Intersector.selfX" title="Intersector.selfX"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.selfX</span></code></a></p></td>
<td><p>Checks  self-intersections in a mesh.</p></td>
</tr>
</tbody>
</table>
<p><strong>&#8211; Transformation Functions</strong></p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#Intersector.triangulateBC" title="Intersector.triangulateBC"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.triangulateBC</span></code></a></p></td>
<td><p>Triangulates specified polygons of a volume mesh.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Intersector.triangulateExteriorFaces" title="Intersector.triangulateExteriorFaces"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.triangulateExteriorFaces</span></code></a></p></td>
<td><p>Triangulates exterior polygons of a volume mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Intersector.reorient" title="Intersector.reorient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.reorient</span></code></a></p></td>
<td><p>Reorients outward the external polygons of a mesh.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Intersector.convexifyFaces" title="Intersector.convexifyFaces"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.convexifyFaces</span></code></a></p></td>
<td><p>Convexifies any non-convex polygon in a mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Intersector.syncMacthPeriodicFaces" title="Intersector.syncMacthPeriodicFaces"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.syncMacthPeriodicFaces</span></code></a></p></td>
<td><p>Force periodicity for faces that are supposed to be periodic.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Intersector.prepareCellsSplit" title="Intersector.prepareCellsSplit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.prepareCellsSplit</span></code></a></p></td>
<td><p>Splits some prescribed polygons following a prescribed splitting policy.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Intersector.splitNonStarCells" title="Intersector.splitNonStarCells"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.splitNonStarCells</span></code></a></p></td>
<td><p>Splits some non-centroid-star_shaped cells.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Intersector.agglomerateSmallCells" title="Intersector.agglomerateSmallCells"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.agglomerateSmallCells</span></code></a></p></td>
<td><p>Agglomerates prescribed cells.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Intersector.agglomerateNonStarCells" title="Intersector.agglomerateNonStarCells"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.agglomerateNonStarCells</span></code></a></p></td>
<td><p>Agglomerates non-centroid-star-shaped cells.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Intersector.agglomerateCellsWithSpecifiedFaces" title="Intersector.agglomerateCellsWithSpecifiedFaces"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.agglomerateCellsWithSpecifiedFaces</span></code></a></p></td>
<td><p>Agglomerates cells to make disappear specified polygons.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Intersector.simplifyCells" title="Intersector.simplifyCells"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.simplifyCells</span></code></a></p></td>
<td><p>Simplifies over-defined polyhedral cells (agglomerate some elligible polygons).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Intersector.closeCells" title="Intersector.closeCells"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.closeCells</span></code></a></p></td>
<td><p>Closes any polyhedral cell in a mesh (processes hanging nodes on edges).</p></td>
</tr>
</tbody>
</table>
<p><strong>&#8211; Adaptation Specific Functions</strong></p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#Intersector.adaptBox" title="Intersector.adaptBox"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.adaptBox</span></code></a></p></td>
<td><p>Adapts a bounding box to a cloud of interior points</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Intersector.createHMesh" title="Intersector.createHMesh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.createHMesh</span></code></a></p></td>
<td><p>Returns a hierarchical zone hook.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Intersector.deleteHMesh" title="Intersector.deleteHMesh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.deleteHMesh</span></code></a></p></td>
<td><p>Releases a hierachical zone hook.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Intersector.conformizeHMesh" title="Intersector.conformizeHMesh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.conformizeHMesh</span></code></a></p></td>
<td><p>Converts the basic element leaves of a hierarchical mesh to a conformal polyhedral mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Intersector.createSensor" title="Intersector.createSensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.createSensor</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Intersector.assignData2Sensor" title="Intersector.assignData2Sensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.assignData2Sensor</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Intersector.deleteSensor" title="Intersector.deleteSensor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.deleteSensor</span></code></a></p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<p><strong>&#8211; Metric Functions</strong></p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#Intersector.edgeLengthExtrema" title="Intersector.edgeLengthExtrema"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.edgeLengthExtrema</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Intersector.volumes" title="Intersector.volumes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.volumes</span></code></a></p></td>
<td><p>Computes cells volumes in a.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Intersector.centroids" title="Intersector.centroids"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.centroids</span></code></a></p></td>
<td><p>Computes cells centroids in a.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Intersector.computeGrowthRatio" title="Intersector.computeGrowthRatio"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.computeGrowthRatio</span></code></a></p></td>
<td><p>Returns a field of growth ratio.</p></td>
</tr>
</tbody>
</table>
<p><strong>&#8211; Extraction Functions</strong></p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#Intersector.extractPathologicalCells" title="Intersector.extractPathologicalCells"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.extractPathologicalCells</span></code></a></p></td>
<td><p>Extracts all cells that will probably cause trouble to a CFD solver.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Intersector.extractOuterLayers" title="Intersector.extractOuterLayers"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.extractOuterLayers</span></code></a></p></td>
<td><p>Extracts prescribed outer cell layers.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Intersector.getCells" title="Intersector.getCells"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.getCells</span></code></a></p></td>
<td><p>Returns the cells in t1 having specified faces or cell ids.</p></td>
</tr>
</tbody>
</table>
<p><strong>&#8211; Check Functions</strong></p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#Intersector.diffMesh" title="Intersector.diffMesh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.diffMesh</span></code></a></p></td>
<td><p>Returns the difference between 2 meshes as 2 zones.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Intersector.checkCellsClosure" title="Intersector.checkCellsClosure"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.checkCellsClosure</span></code></a></p></td>
<td><p>Returns the first cell id that is open.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Intersector.checkCellsFlux" title="Intersector.checkCellsFlux"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.checkCellsFlux</span></code></a></p></td>
<td><p>Returns the cell id for which the Gauss flux is the greatest.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#Intersector.checkCellsVolume" title="Intersector.checkCellsVolume"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.checkCellsVolume</span></code></a></p></td>
<td><p>Computes the minimum volume using the input orientation (ParentElement).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#Intersector.checkForDegenCells" title="Intersector.checkForDegenCells"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.checkForDegenCells</span></code></a></p></td>
<td><p>Checks if there are any cell with less than 4 faces.</p></td>
</tr>
</tbody>
</table>
<p><strong>&#8211; Conversion Functions</strong></p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#Intersector.convertNGON2DToNGON3D" title="Intersector.convertNGON2DToNGON3D"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Intersector.convertNGON2DToNGON3D</span></code></a></p></td>
<td><p>Converts a Cassiopee NGON Format for polygons (Face/Edge) to a Face/Node Format.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="contents">
<h2>Contents</h2>
<section id="main-functions">
<h3>Main Functions</h3>
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.conformUnstr">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">conformUnstr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">left_or_right</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">itermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Makes conformal a TRI or a BAR soup (i.e. a set of elements not necessarily connected as a mesh) by detecting and solving all the collisions between elements.</p>
<p>Colliding elements are cut to get a conformal set. Mixing types BAR and TRI is not currently handled.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a1</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; First input mesh (BAR or TRI).</p></li>
<li><p><strong>a2</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Second input mesh (BAR or TRI). If s2 is &#8216;None&#8217; self-intersections are solved over s1.</p></li>
<li><p><strong>tol</strong> (<em>float</em>) &#8211; Merging tolerance when points (existing or computed by intersections) are too close.</p></li>
<li><p><strong>left_or_right</strong> (<em>0</em><em>, </em><em>1</em><em> or </em><em>2</em>) &#8211; Tells the function what to ouput : the transformed s1 (0), s2(1) or both (2).</p></li>
<li><p><strong>itermax</strong> (<em>int</em>) &#8211; Number of intersection/merging iterations. 10 is the default value.</p></li>
</ul>
</dd>
</dl>
<p><em>Tips and Notes:</em></p>
<ul class="simple">
<li><p>Set itermax to 1. to improve speed and the Delaunay kernel robustness. The result might have poorer quality triangles though.</p></li>
<li><p>Tolerance :</p>
<ul>
<li><p>if tol &gt; 0. : the value is used as an absolute overall tolerance</p></li>
<li><p>if tol = 0. : a value is computed as being 5% of the smallest edge length.</p></li>
<li><p>if tol &lt; 0. : MIN(5%, -tol) is used as a ratio to apply to the smallest edge length to get the tolerance.</p></li>
</ul>
</li>
</ul>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/conformUnstr.py">Makes conform a TRI or BAR soup (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - conformUnstr (array) -</span>
<span class="c1"># Conforming 1 or 2 TRI/BAR together (same type for both operands</span>
<span class="kn">import</span> <span class="nn">Generator</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Intersector</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Geom</span> <span class="k">as</span> <span class="nn">D</span>
<span class="kn">from</span> <span class="nn">Geom.Parametrics</span> <span class="kn">import</span> <span class="n">base</span>
<span class="kn">import</span> <span class="nn">Transform</span> <span class="k">as</span> <span class="nn">T</span>

<span class="n">s1</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">sphere</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="n">s2</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">surface</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="s1">&#39;plane&#39;</span><span class="p">],</span> <span class="n">N</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="n">s2</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="p">(</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">))</span>

<span class="n">s1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2Tetra</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
<span class="n">s2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2Tetra</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">conformUnstr</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="s1">&#39;out.plt&#39;</span><span class="p">)</span>

<span class="n">c1</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">circle</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">c2</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">circle</span><span class="p">((</span><span class="mf">0.2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>

<span class="n">c1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2Tetra</span><span class="p">(</span><span class="n">c1</span><span class="p">);</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span>
<span class="n">c2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2Tetra</span><span class="p">(</span><span class="n">c2</span><span class="p">);</span> <span class="n">c2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">conformUnstr</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="s1">&#39;out1.plt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/conformUnstrPT.py">Makes conform a TRI or BAR soup (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - conformUnstr (pyTree) -</span>
<span class="c1"># Conforming 1 or 2 TRI/BAR together (same type for both operands)</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Geom.PyTree</span> <span class="k">as</span> <span class="nn">D</span>
<span class="kn">from</span> <span class="nn">Geom.Parametrics</span> <span class="kn">import</span> <span class="n">base</span>
<span class="kn">import</span> <span class="nn">Transform.PyTree</span> <span class="k">as</span> <span class="nn">T</span>

<span class="n">s1</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">sphere</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>

<span class="n">s2</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">surface</span><span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="s1">&#39;plane&#39;</span><span class="p">],</span> <span class="n">N</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="n">s2</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="p">(</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">))</span>

<span class="n">s1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2Tetra</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
<span class="n">s2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2Tetra</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">conformUnstr</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;out.plt&#39;</span><span class="p">)</span>

<span class="n">c1</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">circle</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">c2</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">circle</span><span class="p">((</span><span class="mf">0.2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>

<span class="n">c1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2Tetra</span><span class="p">(</span><span class="n">c1</span><span class="p">);</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span>
<span class="n">c2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2Tetra</span><span class="p">(</span><span class="n">c2</span><span class="p">);</span> <span class="n">c2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">conformUnstr</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;out1.plt&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.booleanUnion">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">booleanUnion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_right</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solid_right</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">agg_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extrude_pgs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multi_zone</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Creates a conformal union between two components, either TRI surfaces or Polyhedral volumes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a1</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; First mesh operand.</p></li>
<li><p><strong>a2</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Second mesh operand.</p></li>
<li><p><strong>tol</strong> (<em>float</em>) &#8211; Merging tolerance when points (existing or computed by intersections) are too close.</p></li>
<li><p><strong>preserve_right</strong> (<em>0</em><em> or </em><em>1</em>) &#8211; Indicates the merging direction, either a1-&gt;a2 or a2-&gt;a1. If set to 1(0), it means a1-&gt;a2 (a2-&gt;a1), i.e. a2(a1)&#8217;s points are preserved.</p></li>
<li><p><strong>solid_right</strong> (<em>0</em><em> or </em><em>1</em>) &#8211; Indicates that the second operand is not penetrable, i.e. it is prioritized over the first operand a1.</p></li>
<li><p><strong>agg_mode</strong> (<em>0</em><em>,</em><em>1</em><em> or </em><em>2.</em>) &#8211; Option for agglomerating cut polygons: 0 to keep them as split triangles, 1 to get convex agglomerations and 2 to get a full agglomeration.</p></li>
<li><p><strong>extrude_pgs</strong> (<em>list</em><em> of </em><em>int</em>) &#8211; Optional list of polygons to extrude.</p></li>
<li><p><strong>multi_zone</strong> (<em>True</em><em> or </em><em>False</em>) &#8211; If set to True, preserve input zoning of a1 and a2 upon exit.</p></li>
</ul>
</dd>
</dl>
<p><strong>Prerequisites :</strong></p>
<ul class="simple">
<li><p>External polygons must be oriented consistently and outwardly (use Transform.reorderAll before)</p></li>
</ul>
<p><em>Tips and Notes:</em></p>
<ul class="simple">
<li><p>For assembling meshes, set solid_right to 1 and pass the prioritized mesh as second operand.</p></li>
<li><p>extrude_pgs: required whenever a1 and a2 are in contact and a2 is prioritized: avoids to compute useless intersections by telling what are the indices of contact polygons in a2.</p></li>
</ul>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/booleanUnion.py">Union of two spherical surface meshes (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - booleanUnion (array) -</span>
<span class="kn">import</span> <span class="nn">Intersector</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Generator</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Geom</span> <span class="k">as</span> <span class="nn">D</span>

<span class="n">s1</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">sphere</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">s2</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">sphere</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>

<span class="n">s1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2Tetra</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
<span class="n">s2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2Tetra</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">booleanUnion</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="s1">&#39;out.plt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/booleanUnionNGPT.py">Union of two volume meshes (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - boolean union (PyTree) -</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>

<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2PyTree</span><span class="p">(</span><span class="s1">&#39;boolNG_M1.tp&#39;</span><span class="p">)</span>
<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M1</span><span class="p">)</span>

<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2PyTree</span><span class="p">(</span><span class="s1">&#39;boolNG_M2.tp&#39;</span><span class="p">)</span>
<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M2</span><span class="p">)</span>

<span class="n">tol</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5e-3</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">booleanUnion</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span> <span class="n">M2</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">preserve_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">solid_right</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Base&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">]);</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;boolNGunion11.cgns&#39;</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">booleanUnion</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span> <span class="n">M2</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">preserve_right</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">solid_right</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Base&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">]);</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;boolNGunion01.cgns&#39;</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">booleanUnion</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span> <span class="n">M2</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">preserve_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">solid_right</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Base&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">]);</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;boolNGunion10.cgns&#39;</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">booleanUnion</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span> <span class="n">M2</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">preserve_right</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">solid_right</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Base&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">]);</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;boolNGunion00.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.booleanIntersection">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">booleanIntersection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_right</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solid_right</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">agg_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Computes a conformal intersection between two components, either TRI surfaces or Polyhedral volumes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a1</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; First mesh operand.</p></li>
<li><p><strong>a2</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Second mesh operand.</p></li>
<li><p><strong>tol</strong> (<em>float</em>) &#8211; Merging tolerance when points (existing or computed by intersections) are too close.</p></li>
<li><p><strong>preserve_right</strong> (<em>0</em><em> or </em><em>1</em>) &#8211; Indicates the merging direction, either a1-&gt;a2 or a2-&gt;a1. If set to 1(0), it means a1-&gt;a2 (a2-&gt;a1), i.e. a2(a1)&#8217;s points are preserved.</p></li>
<li><p><strong>solid_right</strong> (<em>0</em><em> or </em><em>1</em>) &#8211; Indicates that the second operand is not penetrable, i.e. it is prioritized over the first operand a1.</p></li>
<li><p><strong>agg_mode</strong> (<em>0</em><em>,</em><em>1</em><em> or </em><em>2.</em>) &#8211; Option for agglomerating cut polygons : 0 to keep them as split triangles, 1 to get convex agglomerations and 2 to get a full agglomeration.</p></li>
</ul>
</dd>
</dl>
<p><strong>Prerequisites :</strong></p>
<ul class="simple">
<li><p>External polygons must be oriented consistently and outwardly (use Transform.reorderAll before)</p></li>
</ul>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/booleanIntersection.py">Intersection of two spherical surface meshes (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - boolean intersection (array) -</span>
<span class="kn">import</span> <span class="nn">Intersector</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Generator</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Geom</span> <span class="k">as</span> <span class="nn">D</span>

<span class="n">s1</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">sphere</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">s2</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">sphere</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>

<span class="n">s1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2Tetra</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
<span class="n">s2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2Tetra</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">booleanIntersection</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="s1">&#39;out.plt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/booleanIntersectionNGPT.py">Intersection of two volume meshes (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - boolean intersection (PyTree) -</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>

<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2PyTree</span><span class="p">(</span><span class="s1">&#39;boolNG_M1.tp&#39;</span><span class="p">)</span>
<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M1</span><span class="p">)</span>

<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2PyTree</span><span class="p">(</span><span class="s1">&#39;boolNG_M2.tp&#39;</span><span class="p">)</span>
<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M2</span><span class="p">)</span>

<span class="n">tol</span> <span class="o">=</span> <span class="mf">1.e-12</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">booleanIntersection</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span> <span class="n">M2</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">preserve_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">solid_right</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Base&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">x</span><span class="p">])</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;boolNGinter11.cgns&#39;</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">booleanIntersection</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span> <span class="n">M2</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">preserve_right</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">solid_right</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;boolNGinter01.cgns&#39;</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">booleanIntersection</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span> <span class="n">M2</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">preserve_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">solid_right</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;boolNGinter10.cgns&#39;</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">booleanIntersection</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span> <span class="n">M2</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">preserve_right</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">solid_right</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;boolNGinter00.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.booleanMinus">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">booleanMinus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_right</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solid_right</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">agg_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Computes a conformal difference between two components, either TRI surfaces or Polyhedral volumes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a1</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; First mesh operand.</p></li>
<li><p><strong>a2</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Second mesh operand.</p></li>
<li><p><strong>tol</strong> (<em>float</em>) &#8211; Merging tolerance when points (existing or computed by intersections) are too close.</p></li>
<li><p><strong>preserve_right</strong> (<em>0</em><em> or </em><em>1</em>) &#8211; Indicates the merging direction, either a1-&gt;a2 or a2-&gt;a1. If set to 1(0), it means a1-&gt;a2 (a2-&gt;a1), i.e. a2(a1)&#8217;s points are preserved.</p></li>
<li><p><strong>solid_right</strong> (<em>0</em><em> or </em><em>1</em>) &#8211; Indicates that the second operand is not penetrable, i.e. it is prioritized over the first operand a1.</p></li>
<li><p><strong>agg_mode</strong> (<em>0</em><em>,</em><em>1</em><em> or </em><em>2.</em>) &#8211; Option for agglomerating cut polygons : 0 to keep them as split triangles, 1 to get convex agglomerations and 2 to get a full agglomeration.</p></li>
</ul>
</dd>
</dl>
<p><strong>Prerequisites :</strong></p>
<ul class="simple">
<li><p>External polygons must be oriented consistently and outwardly (use Transform.reorderAll before)</p></li>
</ul>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/booleanMinus.py">Difference of two spherical surface meshes (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - booleanMinus (array) -</span>
<span class="kn">import</span> <span class="nn">Intersector</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Generator</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Geom</span> <span class="k">as</span> <span class="nn">D</span>

<span class="n">s1</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">sphere</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">s2</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">sphere</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>

<span class="n">s1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2Tetra</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
<span class="n">s2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2Tetra</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">booleanMinus</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="s1">&#39;out.plt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/booleanMinusNGPT.py">Difference of two volume meshes (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - boolean minus (PyTree) -</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>

<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2PyTree</span><span class="p">(</span><span class="s1">&#39;boolNG_M1.tp&#39;</span><span class="p">)</span>
<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M1</span><span class="p">)</span>

<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2PyTree</span><span class="p">(</span><span class="s1">&#39;boolNG_M2.tp&#39;</span><span class="p">)</span>
<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M2</span><span class="p">)</span>

<span class="n">tol</span> <span class="o">=</span> <span class="mf">1.e-12</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">booleanMinus</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span> <span class="n">M2</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">preserve_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">solid_right</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Base&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">]);</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;boolNGminus11.cgns&#39;</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">booleanMinus</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span> <span class="n">M2</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">preserve_right</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">solid_right</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Base&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">]);</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;boolNGminus01.cgns&#39;</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">booleanMinus</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span> <span class="n">M2</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">preserve_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">solid_right</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Base&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">]);</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;boolNGminus10.cgns&#39;</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">booleanMinus</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span> <span class="n">M2</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">preserve_right</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">solid_right</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Base&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">]);</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;boolNGminus00.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.intersection">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">intersection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns the &#8216;BAR&#8217; contour defining the intersection between two TRI-surfaces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a1</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; First mesh operand.</p></li>
<li><p><strong>a2</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Second mesh operand.</p></li>
<li><p><strong>tol</strong> (<em>float</em>) &#8211; Merging tolerance when points (existing or computed by intersections) are too close.</p></li>
</ul>
</dd>
</dl>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/intersection.py">Circular trace of the intersection between two spheres (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - intersection (array) -</span>
<span class="kn">import</span> <span class="nn">Intersector</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Generator</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Geom</span> <span class="k">as</span> <span class="nn">D</span>

<span class="n">s1</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">sphere</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">s2</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">sphere</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="n">s1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2Tetra</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
<span class="n">s2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2Tetra</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="s1">&#39;out.plt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/intersectionPT.py">Circular trace of the intersection between two spheres (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - intersection (pyTree) -</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Geom.PyTree</span> <span class="k">as</span> <span class="nn">D</span>

<span class="n">s1</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">sphere</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">s2</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">sphere</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="n">s1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2Tetra</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
<span class="n">s2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2Tetra</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.diffSurf">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">diffSurf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_right</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">agg_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Cut-cell function : Computes a conformal difference between a volume mesh and a surface mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a1</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; First mesh operand.</p></li>
<li><p><strong>a2</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Second mesh operand.</p></li>
<li><p><strong>tol</strong> (<em>float</em>) &#8211; Merging tolerance when points (existing or computed by intersections) are too close.</p></li>
<li><p><strong>preserve_right</strong> (<em>0</em><em> or </em><em>1</em>) &#8211; Indicates the merging direction, either a1-&gt;a2 or a2-&gt;a1. If set to 1(0), it means a1-&gt;a2 (a2-&gt;a1), i.e. a2(a1)&#8217;s points are preserved.</p></li>
<li><p><strong>solid_right</strong> (<em>0</em><em> or </em><em>1</em>) &#8211; Indicates that the second operand is not penetrable, i.e. it is prioritized over the first operand a1.</p></li>
<li><p><strong>agg_mode</strong> (<em>0</em><em>,</em><em>1</em><em> or </em><em>2.</em>) &#8211; Option for agglomerating cut polygons : 0 to keep them as split triangles, 1 to get convex agglomerations and 2 to get a full agglomeration.</p></li>
</ul>
</dd>
</dl>
<p><strong>Prerequisites :</strong></p>
<ul class="simple">
<li><p>External polygons must be oriented consistently and outwardly (use Transform.reorderAll before)</p></li>
<li><p>The surface format must be an NGON Face/Node (apply before Intersector.convertNGON2DToNGON3D on the surface)</p></li>
</ul>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/diffSurf.py">Cut-cell mesh with an octree and a sphere (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - boolean diffSurf (array) -</span>
<span class="kn">import</span> <span class="nn">Generator</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Geom</span> <span class="k">as</span> <span class="nn">D</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Intersector</span> <span class="k">as</span> <span class="nn">XOR</span>

<span class="c1"># octree</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">sphere</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mf">1.</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span> <span class="n">snear</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">octree</span><span class="p">([</span><span class="n">s</span><span class="p">],[</span><span class="n">snear</span><span class="p">],</span> <span class="n">dfar</span><span class="o">=</span><span class="mf">5.</span><span class="p">,</span> <span class="n">balancing</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">ratio</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># ngon converion</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="c1"># ngon conformization</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">conformizeNGon</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="n">t</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="c1"># ngon close cells</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">closeCells</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="c1">#t = XOR.reorientExternalFaces(t)</span>

<span class="c1"># ngon converion of the sphere</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="c1"># ngon converion to the nuga format</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">convertNGON2DToNGON3D</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="c1">#s = XOR.reorientExternalFaces(s)</span>

<span class="c1"># Boolean operation</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">diffSurf</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">preserve_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">agg_mode</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># agg_mode=2 : full mode aggregation</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="s1">&#39;out.plt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/diffSurfPT.py">Cut-cell mesh with an octree and a sphere (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - boolean diffSurf (PyTree) -</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Geom.PyTree</span> <span class="k">as</span> <span class="nn">D</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>

<span class="c1"># octree</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">sphere</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mf">1.</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span> <span class="n">snear</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">octree</span><span class="p">([</span><span class="n">s</span><span class="p">],[</span><span class="n">snear</span><span class="p">],</span> <span class="n">dfar</span><span class="o">=</span><span class="mf">5.</span><span class="p">,</span> <span class="n">balancing</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">ratio</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># ngon converion</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="c1"># ngon conformization</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">conformizeNGon</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="n">t</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="c1"># ngon close cells</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">closeCells</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="c1">#t = XOR.reorientExternalFaces(t)</span>

<span class="c1"># ngon converion of the sphere</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="c1"># ngon converion to the nuga format</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">convertNGON2DToNGON3D</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="c1">#s = XOR.reorientExternalFaces(s)</span>

<span class="c1"># Boolean operation</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">diffSurf</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">preserve_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">agg_mode</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># agg_mode=2 : full mode aggregation</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Base&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">]);</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;diffs.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.PyTree.XcellN">
<span class="sig-prename descclassname"><span class="pre">Intersector.PyTree.</span></span><span class="sig-name descname"><span class="pre">XcellN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">priorities</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Computes the visibility coefficient for each cell in an overset surface grid configuration t with one-to-one priorities. t can be structured or unstructured.</p>
<p>Depending on the output_type argument, this function computes:</p>
<ul class="simple">
<li><p>a ternary blanking information (0 (hidden), 1(visible) and 0.5(colliding), when output_type=0</p></li>
<li><p>a continuous blanking information (any val in [0,1] based on the ratio of the visible part of the cell), when output_type=1</p></li>
<li><p>a clipped polygonal surface (NGON format) where all the hidden surface parts have been removed, when output_type=2</p></li>
</ul>
<a class="reference internal image-reference" href="_images/xcelln_conf.jpg"><img alt="_images/xcelln_conf.jpg" src="_images/xcelln_conf.jpg" style="width: 24%;" /></a>
<a class="reference internal image-reference" href="_images/xcelln_mode0.jpg"><img alt="_images/xcelln_mode0.jpg" src="_images/xcelln_mode0.jpg" style="width: 24%;" /></a>
<a class="reference internal image-reference" href="_images/xcelln_mode1.jpg"><img alt="_images/xcelln_mode1.jpg" src="_images/xcelln_mode1.jpg" style="width: 24%;" /></a>
<a class="reference internal image-reference" href="_images/xcelln_mode2.jpg"><img alt="_images/xcelln_mode2.jpg" src="_images/xcelln_mode2.jpg" style="width: 24%;" /></a>
<p><em>From left to right: Sphere made of 2 overset patches, results with output_type=0,1 and 2 displayed for the non-prioritized patch.</em></p>
<p>When output_type is 0 or 1, a &#8216;xcelln&#8217; field is added to each zone of the PyTree.
When output_type is 2, the fields defined at center are transferred in the output mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> (<em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em><em>.</em>) &#8211; an overset surface mesh where components are separated in different bases.</p></li>
<li><p><strong>priorities</strong> (<em>list</em><em> of </em><em>pairs</em><em> of </em><em>integers.</em>) &#8211; list of one-to-one pairs of priorities between components.</p></li>
<li><p><strong>output_type</strong> (<em>0</em><em>, </em><em>1</em><em> or </em><em>2.</em>) &#8211; ternary blanking field.</p></li>
<li><p><strong>rtol</strong> (<em>float.</em>) &#8211; relative tolerance for detecting and computing intersections.</p></li>
</ul>
</dd>
</dl>
<p><strong>Prerequisites :</strong></p>
<ul class="simple">
<li><p>All the surface patches must be oriented consistently and outwardly (use Transform.reorderAll before)</p></li>
</ul>
<p><strong>Tips and Notes:</strong></p>
<ul class="simple">
<li><p>each component must set in a separate base.</p></li>
<li><p>priorisation and computation is done between components only : not between zones of the same base.</p></li>
<li><p>wall boundaries are considered whatever the priorisation:</p></li>
</ul>
<a class="reference internal image-reference" href="_images/xcelln_prior_conf.jpg"><img alt="_images/xcelln_prior_conf.jpg" src="_images/xcelln_prior_conf.jpg" style="width: 30%;" /></a>
<a class="reference internal image-reference" href="_images/xcelln_prior1.jpg"><img alt="_images/xcelln_prior1.jpg" src="_images/xcelln_prior1.jpg" style="width: 30%;" /></a>
<a class="reference internal image-reference" href="_images/xcelln_prior2.jpg"><img alt="_images/xcelln_prior2.jpg" src="_images/xcelln_prior2.jpg" style="width: 30%;" /></a>
<p><em>Example of wall treatment on the fuselage/collar zone of a CRM configuration when output_type is 2: if the collar is prioritized (middle) or not (right), the part of the fuselage falling inside the wing is clipped.</em></p>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/xcellnSphYinYangPT.py">xcelln field on structured configuration</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - XcellN (PyTree) -</span>
<span class="kn">import</span> <span class="nn">Geom.PyTree</span> <span class="k">as</span> <span class="nn">D</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Converter.Internal</span> <span class="k">as</span> <span class="nn">I</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">sphereYinYang</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mf">1.</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="n">zs</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">getZones</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Base&#39;</span><span class="p">,</span> <span class="n">zs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;Base2&#39;</span><span class="p">,</span> <span class="n">zs</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

<span class="n">priorities</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">priorities</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

<span class="n">XOR</span><span class="o">.</span><span class="n">_XcellN</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">priorities</span><span class="p">,</span> <span class="n">output_type</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;out.cgns&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.adaptCells">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">adaptCells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sensdata</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sensor_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smoothing_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">itermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subdiv_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hmesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sensor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conformize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Adapts a cells (any basic cells - TETRA, PENTA, PYRA, HEXA - currently) with respect to the sensor and its data (sensdata).</p>
<p>Adaptation is a per-cell octal 2:1 decomposition.</p>
<p>With a sensor_type equal to :</p>
<ul class="simple">
<li><p>0 (geometrical sensor), sensdata must contain vertices : a will be refined until any a cell contains at most 1 data vertex.</p></li>
<li><p>1 (xsensor), sensdata must be a mesh <em>m</em>, ant its connectivity is also taken into account by adding refinement wherever a cells are crossed by m edges.</p></li>
<li><p>2 (nodal sensor), sensdata are nodal values giving the number of required subdivision around that node.</p></li>
<li><p>3 (cell sensor), sensdata are cell values giving the number of required subdivision per cell.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>[</em><em>array</em><em>] or </em><em>[ </em><em>single zone pyTree</em><em> (</em><em>currently</em><em>)</em><em>]</em>) &#8211; Input mesh (NGON format)</p></li>
<li><p><strong>sensdata</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>] </em><em>for sensor type 0 and 1. Numpy</em><em> of </em><em>integers for other sensors.</em>) &#8211; Data for the sensor</p></li>
<li><p><strong>sensor_type</strong> (<em>int</em>) &#8211; type of sensor. geometrical (0), xensor (1), nodal sensor (2), cell sensor (3)</p></li>
<li><p><strong>smoothing_type</strong> (<em>int</em>) &#8211; first-neighborhood (0), shell-neighborhood(1)</p></li>
<li><p><strong>itermax</strong> (<em>int</em>) &#8211; maximum nb of generations</p></li>
<li><p><strong>subdiv_type</strong> (<em>int</em>) &#8211; type of adaptation, currently only isotropic (0).</p></li>
<li><p><strong>hmesh</strong> (<em>hook</em>) &#8211; structure that holds the hierarchical genealogy structure in case of successive adaptations on a mesh. Instantiated with Intersector.createHMesh</p></li>
<li><p><strong>sensor</strong> (<em>hook</em>) &#8211; structure that holds the sensor and its data in case of successive adaptations on a mesh</p></li>
<li><p><strong>conformize</strong> (<em>int</em>) &#8211; conformal output mesh enabled (1), disabled (0). Enabled by default.</p></li>
</ul>
</dd>
</dl>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/adaptCells.py">adaptCells (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - adapts a cells with respect to b points (array) -</span>
<span class="kn">import</span> <span class="nn">Intersector</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Generator</span> <span class="k">as</span> <span class="nn">G</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cartHexa</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="c1">#C.convertArrays2File([a], &#39;a.plt&#39;)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cartHexa</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.005</span><span class="p">,</span><span class="mf">0.005</span><span class="p">,</span><span class="mf">0.005</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="c1">#C.convertArrays2File([b], &#39;b.plt&#39;)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">adaptCells</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span> <span class="n">sensor_type</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">closeCells</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">([</span><span class="n">m</span><span class="p">],</span> <span class="s1">&#39;out.plt&#39;</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">adaptCells</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span> <span class="n">sensor_type</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">closeCells</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">([</span><span class="n">m</span><span class="p">],</span> <span class="s1">&#39;xout.plt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/adaptCellsPT.py">adaptCells (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - adapts a cells with respect to b points (PyTree) -</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cartHexa</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="c1">#C.convertPyTree2File(a, &#39;a.cgns&#39;)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cartHexa</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.005</span><span class="p">,</span><span class="mf">0.005</span><span class="p">,</span><span class="mf">0.005</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="c1">#C.convertPyTree2File(b, &#39;b.cgns&#39;)</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">fillEmptyBCWith</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;wall&#39;</span><span class="p">,</span> <span class="s1">&#39;BCWall&#39;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">initVars</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;{centers:Density} = {centers:CoordinateX} + {centers:CoordinateY}&#39;</span><span class="p">)</span>

<span class="n">XOR</span><span class="o">.</span><span class="n">_setZonesAndJoinsUId</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="c1">## static adaptation</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">adaptCells</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span> <span class="n">sensor_type</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">closeCells</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">adaptCells</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span> <span class="n">sensor_type</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">closeCells</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;xout.cgns&#39;</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">adaptCells</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span> <span class="n">sensor_type</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">smoothing_type</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">closeCells</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;out2.cgns&#39;</span><span class="p">)</span>

<span class="c1">## dynamic adaptation</span>
<span class="n">hmsh</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">createHMesh</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">adaptCells</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">hmesh</span><span class="o">=</span><span class="n">hmsh</span><span class="p">,</span> <span class="n">sensor_type</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">cm</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">conformizeHMesh</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">hmsh</span><span class="p">)</span>
<span class="n">cm</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">closeCells</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="n">XOR</span><span class="o">.</span><span class="n">deleteHMesh</span><span class="p">(</span><span class="n">hmsh</span><span class="p">);</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="s1">&#39;out3.cgns&#39;</span><span class="p">)</span>

<span class="n">hmsh</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">createHMesh</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">adaptCells</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">hmesh</span><span class="o">=</span><span class="n">hmsh</span><span class="p">,</span> <span class="n">sensor_type</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">smoothing_type</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">cm</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">conformizeHMesh</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">hmsh</span><span class="p">)</span>
<span class="n">cm</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">closeCells</span><span class="p">(</span><span class="n">cm</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="s1">&#39;out4.cgns&#39;</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">adaptCells</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">hmesh</span><span class="o">=</span><span class="n">hmsh</span><span class="p">,</span> <span class="n">sensor_type</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># applied to existing hmesh with the geometrical sensor</span>

<span class="n">cm</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">conformizeHMesh</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="n">hmsh</span><span class="p">)</span>
<span class="n">cm</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">closeCells</span><span class="p">(</span><span class="n">cm</span><span class="p">)</span>

<span class="n">XOR</span><span class="o">.</span><span class="n">deleteHMesh</span><span class="p">(</span><span class="n">hmsh</span><span class="p">);</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">cm</span><span class="p">,</span> <span class="s1">&#39;out5.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><em>Tips and Notes:</em></p>
<ul class="simple">
<li><p>Do this transformation before calling any Volume-Volume boolean operations in order to improve the mesh quality of the result.</p></li>
<li><p>When the input mesh has any kind of polyhedral elements, only basic elements will be considered currently for adaptation. but the result wil be conformal, the non-handled elements will modified to respect the conformity.</p></li>
</ul>
</dd></dl>

</section>
<hr class="docutils" />
<section id="transformation-functions">
<h3>Transformation Functions</h3>
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.triangulateBC">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">triangulateBC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bctype</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Triangulates the prescribed BC type polygons of a volume mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Input mesh</p></li>
<li><p><strong>bctype</strong> (<em>string</em>) &#8211; boundary type (&#8216;BCWall&#8217;, &#8230;).</p></li>
</ul>
</dd>
</dl>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/triangulateBCPT.py">BC polygons triangulation (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - triangulateExteriorFaces (PyTree) -</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2PyTree</span><span class="p">(</span><span class="s1">&#39;boolNG_M1.tp&#39;</span><span class="p">)</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">fillEmptyBCWith</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;wall&#39;</span><span class="p">,</span> <span class="s1">&#39;BCWall&#39;</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

<span class="n">t</span><span class="o">=</span><span class="n">XOR</span><span class="o">.</span><span class="n">triangulateBC</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;BCWall&#39;</span><span class="p">)</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="Intersector.triangulateExteriorFaces">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">triangulateExteriorFaces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_or_out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Triangulates the prescribed external polygons of a volume mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Input mesh</p></li>
<li><p><strong>in_or_out</strong> (<em>0</em><em>,</em><em>1</em><em> or </em><em>2</em>) &#8211; In case of a non-connex mesh (i.e. whith holes like an external airflow mesh around bodies), set to 0 for processing only body walls, set to 1 for processing only the outer boundary, or 2 for processing all of them.</p></li>
</ul>
</dd>
</dl>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/triangulateExteriorFaces.py">External polygons triangulation (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - triangulateExteriorFaces (array) -</span>
<span class="kn">import</span> <span class="nn">Intersector</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2Arrays</span><span class="p">(</span><span class="s1">&#39;boolNG_M1.tp&#39;</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">triangulateExteriorFaces</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">([</span><span class="n">m</span><span class="p">],</span> <span class="s1">&#39;out.plt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/triangulateExteriorFacesPT.py">External polygons triangulation (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - triangulateExteriorFaces (PyTree) -</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2PyTree</span><span class="p">(</span><span class="s1">&#39;boolNG_M1.tp&#39;</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">triangulateExteriorFaces</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.reorient">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">reorient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Reorients outward the external polygons of a mesh.</p>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/reorientExternalFaces.py">Reorientation (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - boolean reorientExternalFaces (array) -</span>
<span class="kn">import</span> <span class="nn">Generator</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Intersector</span> <span class="k">as</span> <span class="nn">XOR</span>


<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cartHexa</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.2</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">reorient</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">([</span><span class="n">a</span><span class="p">],</span> <span class="s1">&#39;out.plt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/reorientExternalFacesPT.py">Reorientation (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - boolean reorientExternalFaces (array) -</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>


<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cartHexa</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.2</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">reorient</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.convexifyFaces">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">convexifyFaces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convexity_TOL</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.e-8</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Makes a convex decomposition of any concave polygon in a mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Input mesh</p></li>
<li><p><strong>convexity_TOL</strong> (<em>float</em>) &#8211; convexity angle threshold</p></li>
</ul>
</dd>
</dl>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/convexifyFaces.py">Convexify polygons (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - convexifyFaces (array) -</span>
<span class="c1"># convexify any concave polygon in the mesh</span>
<span class="kn">import</span> <span class="nn">Intersector</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>

<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2Arrays</span><span class="p">(</span><span class="s1">&#39;boolNG_M1.tp&#39;</span><span class="p">)</span>
<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2Arrays</span><span class="p">(</span><span class="s1">&#39;boolNG_M2.tp&#39;</span><span class="p">)</span>
<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">tol</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5e-3</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">booleanMinus</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span> <span class="n">M2</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">preserve_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">solid_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">agg_mode</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="c1">#full agg to convexify afterward</span>
<span class="c1">#C.convertArrays2File([m], &#39;i.plt&#39;)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">convexifyFaces</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">([</span><span class="n">m</span><span class="p">],</span> <span class="s1">&#39;out.plt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/convexifyFacesPT.py">Convexify polygons (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - convexifyFaces (pyTree) -</span>
<span class="c1"># convexify any concave polygon in the mesh</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>

<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2PyTree</span><span class="p">(</span><span class="s1">&#39;boolNG_M1.tp&#39;</span><span class="p">)</span>
<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M1</span><span class="p">)</span>

<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2PyTree</span><span class="p">(</span><span class="s1">&#39;boolNG_M2.tp&#39;</span><span class="p">)</span>
<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M2</span><span class="p">)</span>

<span class="n">tol</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5e-3</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">booleanMinus</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span> <span class="n">M2</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">preserve_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">solid_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">agg_mode</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="c1">#full agg to convexify afterward</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">convexifyFaces</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.syncMacthPeriodicFaces">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">syncMacthPeriodicFaces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotationCenter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0.,</span> <span class="pre">0.,</span> <span class="pre">0.]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotationAngle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0.,</span> <span class="pre">0.,</span> <span class="pre">0.]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">translation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0.,</span> <span class="pre">0.,</span> <span class="pre">0.]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unitAngle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reorient</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Force periodicity when some faces should be periodic but are not due to connectivity inconsistencies (tipically overdefined or splitted faces).
This function ensures that a following call to Connector.connectMatchPeriodic succeeds when the mesh has been procuced with the intersection strategy.
Periodicity can be defined either by rotation or translation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> (<em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Input mesh</p></li>
<li><p><strong>tol</strong> &#8211; tolerance. Negative value (in [-1; 0]) specifies a relative value base on min edge length in the mesh.</p></li>
</ul>
</dd>
</dl>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/syncPerioFacesPT.py">Synchronize faces(pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - concatenate (PyTree) -</span>

<span class="kn">import</span> <span class="nn">Converter.PyTree</span>   <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span>   <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Connector.PyTree</span>   <span class="k">as</span> <span class="nn">X</span>
<span class="kn">import</span> <span class="nn">Transform.PyTree</span>   <span class="k">as</span> <span class="nn">T</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Post.PyTree</span>        <span class="k">as</span> <span class="nn">P</span>
<span class="kn">import</span> <span class="nn">Converter.Internal</span> <span class="k">as</span> <span class="nn">I</span>

<span class="c1">## build a cartesian mesh</span>
<span class="n">a</span>    <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cartHexa</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),</span> <span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">a</span>    <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="n">XOR</span><span class="o">.</span><span class="n">_reorient</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="c1">## triangulate top face #################</span>
<span class="n">aF</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">exteriorFaces</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">aF</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">splitSharpEdges</span><span class="p">(</span><span class="n">aF</span><span class="p">)</span>
<span class="n">top</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">getZones</span><span class="p">(</span><span class="n">aF</span><span class="p">)[</span><span class="mi">5</span><span class="p">]</span>

<span class="n">BCs</span> <span class="o">=</span> <span class="p">[</span><span class="n">top</span><span class="p">]</span>
<span class="n">BCNames</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;wall&#39;</span><span class="p">]</span>
<span class="n">BCTypes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;BCWallViscous&#39;</span><span class="p">]</span>

<span class="n">C</span><span class="o">.</span><span class="n">_recoverBCs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">BCs</span><span class="p">,</span> <span class="n">BCNames</span><span class="p">,</span> <span class="n">BCTypes</span><span class="p">))</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">triangulateBC</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;BCWallViscous&#39;</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">_deleteZoneBC__</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="c1">#########################################</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">syncMacthPeriodicFaces</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">translation</span><span class="o">=</span><span class="p">[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">9.</span><span class="p">])</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">connectMatchPeriodic</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">translation</span><span class="o">=</span><span class="p">[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">9.</span><span class="p">])</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.prepareCellsSplit">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">prepareCellsSplit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">PH_set</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">split_policy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">PH_conc_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.</span> <span class="pre">/</span> <span class="pre">3.</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">PH_cvx_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">PG_cvx_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.e-8</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Prepares the bad cells split (<a class="reference internal" href="#Intersector.splitNonStarCells" title="Intersector.splitNonStarCells"><code class="xref any py py-func docutils literal notranslate"><span class="pre">splitNonStarCells</span></code></a>) by splitting some of their polygons with a prescribed policy : convexification, starification.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Input mesh</p></li>
<li><p><strong>PH_set</strong> (<em>0</em><em> or </em><em>1</em>) &#8211; PH to process. 0 for concave cells or 1 for non-centroid-star_shaped cells</p></li>
<li><p><strong>split_policy</strong> (<em>0</em><em>,</em><em>1</em><em> or </em><em>2</em>) &#8211; 0 : convexify concave pgs. 1 : starify concave pgs from worst vertex. 2 : starify concave pgs from concave-chains ends.</p></li>
<li><p><strong>PH_conc_threshold</strong> (<em>float</em>) &#8211; Concavity dihedral angle threshold for cells</p></li>
<li><p><strong>PH_cvx_threshold</strong> (<em>float</em>) &#8211; Convexity dihedral angle threshold for cells</p></li>
<li><p><strong>PG_cvx_threshold</strong> (<em>float</em>) &#8211; Convexity angle threshold for polygons</p></li>
</ul>
</dd>
</dl>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/prepareCellsSplit.py">prepareCellsSplit (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - convexify any concave polygon in the mesh (array) -</span>
<span class="kn">import</span> <span class="nn">Intersector</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>

<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2Arrays</span><span class="p">(</span><span class="s1">&#39;boolNG_M1.tp&#39;</span><span class="p">)</span>
<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2Arrays</span><span class="p">(</span><span class="s1">&#39;boolNG_M2.tp&#39;</span><span class="p">)</span>
<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">tol</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5e-3</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">booleanMinus</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span> <span class="n">M2</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">preserve_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">solid_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">agg_mode</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="c1">#full agg to convexify afterward</span>
<span class="c1">#C.convertArrays2File([m], &#39;i.plt&#39;)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">prepareCellsSplit</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">PH_set</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">split_policy</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">PH_conc_threshold</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span><span class="p">,</span> <span class="n">PH_cvx_threshold</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">PG_cvx_threshold</span><span class="o">=</span><span class="mf">1.e-2</span><span class="p">)</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">([</span><span class="n">m</span><span class="p">],</span> <span class="s1">&#39;out.plt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/prepareCellsSplitPT.py">prepareCellsSplit (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - convexify any concave polygon in the mesh (array) -</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>

<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2PyTree</span><span class="p">(</span><span class="s1">&#39;boolNG_M1.tp&#39;</span><span class="p">)</span>
<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M1</span><span class="p">)</span>

<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2PyTree</span><span class="p">(</span><span class="s1">&#39;boolNG_M2.tp&#39;</span><span class="p">)</span>
<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M2</span><span class="p">)</span>

<span class="n">tol</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5e-3</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">booleanMinus</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span> <span class="n">M2</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">preserve_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">solid_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">agg_mode</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="c1">#full agg to convexify afterward</span>
<span class="c1">#C.convertArrays2File([m], &#39;i.plt&#39;)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">prepareCellsSplit</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">PH_set</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">split_policy</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">PH_conc_threshold</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span><span class="p">,</span> <span class="n">PH_cvx_threshold</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">PG_cvx_threshold</span><span class="o">=</span><span class="mf">1.e-2</span><span class="p">)</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.splitNonStarCells">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">splitNonStarCells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">PH_conc_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.</span> <span class="pre">/</span> <span class="pre">3.</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">PH_cvx_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">PG_cvx_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.e-8</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>First strategy to eradicate bad cells : Splits non-centroid-star-shaped (NCSS) cells into two cells. These cells might be NCSS as well so this function should be called several times to get rid off the pathologies. Some call agglomerateSmallCells should be done afterwards to balance the growth ratio.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Input mesh</p></li>
<li><p><strong>PH_conc_threshold</strong> (<em>float</em>) &#8211; Concavity dihedral angle threshold for cells</p></li>
<li><p><strong>PH_cvx_threshold</strong> (<em>float</em>) &#8211; Convexity dihedral angle threshold for cells</p></li>
<li><p><strong>PG_cvx_threshold</strong> (<em>float</em>) &#8211; Convexity angle threshold for polygons</p></li>
</ul>
</dd>
</dl>
<p><em>Tips and Notes:</em></p>
<ul class="simple">
<li><p>Call <a class="reference internal" href="#Intersector.prepareCellsSplit" title="Intersector.prepareCellsSplit"><code class="xref any py py-func docutils literal notranslate"><span class="pre">prepareCellsSplit</span></code></a> before this function to ensure to process as much pathologies as possible.</p></li>
</ul>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/splitCells.py">splitNonStarCells (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - convexify any concave polygon in the mesh (array) -</span>
<span class="kn">import</span> <span class="nn">Intersector</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>

<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2Arrays</span><span class="p">(</span><span class="s1">&#39;boolNG_M1.tp&#39;</span><span class="p">)</span>
<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2Arrays</span><span class="p">(</span><span class="s1">&#39;boolNG_M2.tp&#39;</span><span class="p">)</span>
<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">tol</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5e-3</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">booleanMinus</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span> <span class="n">M2</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">preserve_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">solid_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">agg_mode</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">simplifyCells</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">prepareCellsSplit</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">PH_set</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">split_policy</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">PH_conc_threshold</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span><span class="p">,</span> <span class="n">PH_cvx_threshold</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">PG_cvx_threshold</span><span class="o">=</span><span class="mf">1.e-8</span><span class="p">)</span>
<span class="n">m</span><span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">splitNonStarCells</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">PH_conc_threshold</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span><span class="p">,</span> <span class="n">PH_cvx_threshold</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">PG_cvx_threshold</span><span class="o">=</span><span class="mf">1.e-8</span><span class="p">)</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">([</span><span class="n">m</span><span class="p">],</span> <span class="s1">&#39;out.plt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/splitCellsPT.py">splitNonStarCells (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - convexify any concave polygon in the mesh (array) -</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>

<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2PyTree</span><span class="p">(</span><span class="s1">&#39;boolNG_M1.tp&#39;</span><span class="p">)</span>
<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M1</span><span class="p">)</span>

<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2PyTree</span><span class="p">(</span><span class="s1">&#39;boolNG_M2.tp&#39;</span><span class="p">)</span>
<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M2</span><span class="p">)</span>

<span class="n">tol</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5e-3</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">booleanMinus</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span> <span class="n">M2</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">preserve_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">solid_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">agg_mode</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">simplifyCells</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">prepareCellsSplit</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">PH_set</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">split_policy</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">PH_conc_threshold</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span><span class="p">,</span> <span class="n">PH_cvx_threshold</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">PG_cvx_threshold</span><span class="o">=</span><span class="mf">1.e-8</span><span class="p">)</span>
<span class="n">m</span><span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">splitNonStarCells</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">PH_conc_threshold</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span><span class="p">,</span> <span class="n">PH_cvx_threshold</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">PG_cvx_threshold</span><span class="o">=</span><span class="mf">1.e-8</span><span class="p">)</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.simplifyCells">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">simplifyCells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">treat_externals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angular_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.e-12</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Agglomerates superfluous polygons that over-defines cells. After agglomerating (e.g. after calling <a class="reference internal" href="#Intersector.agglomerateSmallCells" title="Intersector.agglomerateSmallCells"><code class="xref any py py-func docutils literal notranslate"><span class="pre">agglomerateSmallCells</span></code></a>) , we end up with cells that are multiply-connected, i.e. they share more than one polygon.
If 2 cells share 2 polygons that are connected (sharing an edge) and their dihedral angle is below the angular_threshold, then the polygons are agglomerated upon exit. The angular threshold (expressed in radian) is the maximum aboslute deviation around the planar position.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Input mesh</p></li>
<li><p><strong>treat_externals</strong> (<em>0</em><em> or </em><em>1</em>) &#8211; Process outer polygons (1) or not (0).</p></li>
<li><p><strong>angular_threshold</strong> (<em>float</em>) &#8211; Largest angular deviation admitted between adjacent polygons in order to allow their agglomeration.</p></li>
</ul>
</dd>
</dl>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/simplifyCells.py">simplifyCells (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - convexify any concave polygon in the mesh (array) -</span>
<span class="kn">import</span> <span class="nn">Intersector</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>

<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2Arrays</span><span class="p">(</span><span class="s1">&#39;boolNG_M1.tp&#39;</span><span class="p">)</span>
<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2Arrays</span><span class="p">(</span><span class="s1">&#39;boolNG_M2.tp&#39;</span><span class="p">)</span>
<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">tol</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5e-3</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">booleanMinus</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span> <span class="n">M2</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">preserve_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">solid_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">agg_mode</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">#C.convertArrays2File([m], &#39;i.plt&#39;)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">simplifyCells</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">([</span><span class="n">m</span><span class="p">],</span> <span class="s1">&#39;out.plt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/simplifyCellsPT.py">simplifyCells (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - convexify any concave polygon in the mesh (array) -</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>

<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2PyTree</span><span class="p">(</span><span class="s1">&#39;boolNG_M1.tp&#39;</span><span class="p">)</span>
<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M1</span><span class="p">)</span>

<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2PyTree</span><span class="p">(</span><span class="s1">&#39;boolNG_M2.tp&#39;</span><span class="p">)</span>
<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M2</span><span class="p">)</span>

<span class="n">tol</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5e-3</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">booleanMinus</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span> <span class="n">M2</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">preserve_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">solid_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">agg_mode</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">simplifyCells</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.agglomerateSmallCells">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">agglomerateSmallCells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angular_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.e-12</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Agglomerates cells that are too small (below vmin) or having a poor growth ratio with a neighbor (below vratio) with the best neighbor available. The agglomeration process does not create non-star-shaped agglomerates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Input mesh</p></li>
<li><p><strong>vmin</strong> (<em>float</em>) &#8211; volume threshold.</p></li>
<li><p><strong>vratio</strong> (<em>float</em>) &#8211; growth ratio threshold.</p></li>
<li><p><strong>angular_threshold</strong> (<em>float</em>) &#8211; Largest angular deviation admitted between adjacent polygons in order to allow their agglomeration.</p></li>
</ul>
</dd>
</dl>
<p><em>Tips and Notes:</em></p>
<ul class="simple">
<li><p>See <a class="reference internal" href="#Intersector.computeGrowthRatio" title="Intersector.computeGrowthRatio"><code class="xref any py py-func docutils literal notranslate"><span class="pre">computeGrowthRatio</span></code></a> to get the definition of the computed growth ratio.</p></li>
</ul>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/agglomerateSmallCells.py">agglomerateSmallCells (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - boolean diffSurf (array) -</span>
<span class="kn">import</span> <span class="nn">Generator</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Geom</span> <span class="k">as</span> <span class="nn">D</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Intersector</span> <span class="k">as</span> <span class="nn">XOR</span>

<span class="c1"># octree</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">sphere</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mf">1.</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span> <span class="n">snear</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">octree</span><span class="p">([</span><span class="n">s</span><span class="p">],</span> <span class="p">[</span><span class="n">snear</span><span class="p">],</span> <span class="n">dfar</span><span class="o">=</span><span class="mf">5.</span><span class="p">,</span> <span class="n">balancing</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># ngon conversion</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="c1"># ngon conformization</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">conformizeNGon</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="n">t</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="c1"># ngon close cells</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">closeCells</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="c1">#t = XOR.reorientExternalFaces(t)</span>

<span class="c1"># ngon conversion of the sphere</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="c1"># ngon conversion to the nuga format</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">convertNGON2DToNGON3D</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="c1">#s = XOR.reorientExternalFaces(s)</span>

<span class="c1"># Boolean operation</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">diffSurf</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">preserve_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">agg_mode</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># agg_mode=2 : full mode aggregation</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;diffsurf.plt&#39;</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">agglomerateSmallCells</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">vratio</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;agg.plt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/agglomerateSmallCellsPT.py">agglomerateSmallCells (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - boolean diffSurf (PyTree) -</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Geom.PyTree</span> <span class="k">as</span> <span class="nn">D</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>

<span class="c1"># octree</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">sphere</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mf">1.</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span> <span class="n">snear</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">octree</span><span class="p">([</span><span class="n">s</span><span class="p">],[</span><span class="n">snear</span><span class="p">],</span> <span class="n">dfar</span><span class="o">=</span><span class="mf">5.</span><span class="p">,</span> <span class="n">balancing</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">ratio</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># ngon converion</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="c1"># ngon conformization</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">conformizeNGon</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="n">t</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="c1"># ngon close cells</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">closeCells</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="c1">#t = XOR.reorientExternalFaces(t)</span>

<span class="c1"># ngon converion of the sphere</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="c1"># ngon converion to the nuga format</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">convertNGON2DToNGON3D</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="c1">#s = XOR.reorientExternalFaces(s)</span>

<span class="c1"># Boolean operation</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">diffSurf</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">preserve_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">agg_mode</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># agg_mode=2 : full mode aggregation</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">agglomerateSmallCells</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">vratio</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">newPyTree</span><span class="p">([</span><span class="s1">&#39;Base&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">]);</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;diffs.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.agglomerateNonStarCells">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">agglomerateNonStarCells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Agglomerate cells that are non-centroid-star-shaped. The agglomeration process does not create non-star-shaped agglomerates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>a</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Input mesh</p>
</dd>
</dl>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/agglomerateNonStarCells.py">agglomerateNonStarCells (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - convexify any concave polygon in the mesh (array) -</span>
<span class="kn">import</span> <span class="nn">Intersector</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>

<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2Arrays</span><span class="p">(</span><span class="s1">&#39;boolNG_M1.tp&#39;</span><span class="p">)</span>
<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2Arrays</span><span class="p">(</span><span class="s1">&#39;boolNG_M2.tp&#39;</span><span class="p">)</span>
<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">tol</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5e-3</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">booleanMinus</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span> <span class="n">M2</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">preserve_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">solid_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">agg_mode</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">#C.convertArrays2File([m], &#39;i.plt&#39;)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">agglomerateNonStarCells</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;out.plt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/agglomerateNonStarCellsPT.py">agglomerateNonStarCells (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - convexify any concave polygon in the mesh (array) -</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>

<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2PyTree</span><span class="p">(</span><span class="s1">&#39;boolNG_M1.tp&#39;</span><span class="p">)</span>
<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M1</span><span class="p">)</span>

<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2PyTree</span><span class="p">(</span><span class="s1">&#39;boolNG_M2.tp&#39;</span><span class="p">)</span>
<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M2</span><span class="p">)</span>

<span class="n">tol</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5e-3</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">booleanMinus</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span> <span class="n">M2</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">preserve_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">solid_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">agg_mode</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">agglomerateNonStarCells</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.agglomerateCellsWithSpecifiedFaces">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">agglomerateCellsWithSpecifiedFaces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pgs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simplify</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Agglomerate cells that are non-centroid-star-shaped. The agglomeration process does not create non-star-shaped agglomerates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Input mesh</p></li>
<li><p><strong>pgs</strong> (<em>list</em><em> of </em><em>integers</em>) &#8211; list of polygons to remove</p></li>
</ul>
</dd>
</dl>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/getOverlappingFaces.py">agglomerateCellsWithSpecifiedFaces (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">Generator</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Transform</span> <span class="k">as</span> <span class="nn">T</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">I</span>
<span class="kn">import</span> <span class="nn">Intersector</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">KCore.test</span> <span class="k">as</span> <span class="nn">test</span>
<span class="kn">import</span> <span class="nn">Post</span> <span class="k">as</span> <span class="nn">P</span>

<span class="n">t1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">t1</span><span class="p">);</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mf">1.</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">t2</span><span class="p">);</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>

<span class="c1"># test 1 : volume/volume</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">getOverlappingFaces</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">RTOL</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">amax</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># create a list of polygon list (t1), one list per zone</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">agglomerateCellsWithSpecifiedFaces</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">([</span><span class="n">t</span><span class="p">],</span> <span class="s2">&quot;out.plt&quot;</span><span class="p">)</span>

<span class="c1">#test 2 : volume/surface</span>

<span class="n">t2</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">exteriorFaces</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">convertNGON2DToNGON3D</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>

<span class="n">res</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">getOverlappingFaces</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">RTOL</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">amax</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">agglomerateCellsWithSpecifiedFaces</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">([</span><span class="n">t</span><span class="p">],</span> <span class="s2">&quot;out1.plt&quot;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/getOverlappingFacesPT.py">agglomerateCellsWithSpecifiedFaces (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Transform.PyTree</span> <span class="k">as</span> <span class="nn">T</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Converter.Internal</span> <span class="k">as</span> <span class="nn">I</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">KCore.test</span> <span class="k">as</span> <span class="nn">test</span>
<span class="kn">import</span> <span class="nn">Post.PyTree</span> <span class="k">as</span> <span class="nn">P</span>

<span class="n">t1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">t1</span><span class="p">);</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mf">1.</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">t2</span><span class="p">);</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>

<span class="c1"># test 1 : volume/volume</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">getOverlappingFaces</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">RTOL</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">amax</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># create a list of polygon list (t1), one list per zone</span>
<span class="n">nb_zones</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
<span class="n">t1zones_pgids</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_zones</span><span class="p">):</span>
    <span class="n">t1zones_pgids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">agglomerateCellsWithSpecifiedFaces</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t1zones_pgids</span><span class="p">)</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;out.cgns&quot;</span><span class="p">)</span>

<span class="c1">#test 2 : volume/surface</span>

<span class="n">t2</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">exteriorFaces</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">convertNGON2DToNGON3D</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>

<span class="n">res</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">getOverlappingFaces</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">RTOL</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">amax</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="n">t1zones_pgids</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_zones</span><span class="p">):</span>
    <span class="n">t1zones_pgids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">agglomerateCellsWithSpecifiedFaces</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t1zones_pgids</span><span class="p">)</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;out1.cgns&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><em>Tips and Notes:</em></p>
<ul class="simple">
<li><p>When assembling 2 meshes m1 and m2 where m2 is priorized, to improve the assembly quality, do before calling the boolean union:</p></li>
</ul>
<ol class="arabic simple">
<li><p>getOverlappingFaces (m1, skin(m2)) where skin(m2) is the external polygonal skin of m2</p></li>
<li><p>agglomerateCellsWithSpecifiedFaces on m1 with the above list of polygons</p></li>
</ol>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.closeCells">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">closeCells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Closed any polyhedral cell in a mesh which is open because it has, and only has, hanging nodes on its edges.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>a</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Input mesh</p>
</dd>
</dl>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/closeCells.py">closeCells (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - closeCells (array) -</span>
<span class="kn">import</span> <span class="nn">Intersector</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2Arrays</span><span class="p">(</span><span class="s1">&#39;boolNG_M1.tp&#39;</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">closeCells</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">([</span><span class="n">m</span><span class="p">],</span> <span class="s1">&#39;out.plt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/closeCellsPT.py">closeCells (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - triangulateExteriorFaces (array) -</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">KCore.test</span> <span class="k">as</span> <span class="nn">test</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2PyTree</span><span class="p">(</span><span class="s1">&#39;boolNG_M1.tp&#39;</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">closeCells</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><em>Tips and Notes:</em></p>
<ul class="simple">
<li><p>Do this transformation whenever you need to use a surface algorithm on the octree (e.g. <a class="reference internal" href="#Intersector.reorient" title="Intersector.reorient"><code class="xref any py py-func docutils literal notranslate"><span class="pre">reorient</span></code></a>)</p></li>
</ul>
</dd></dl>

</section>
<hr class="docutils" />
<section id="adaptation-specific-functions">
<h3>Adaptation Specific Functions</h3>
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.adaptBox">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">adaptBox</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">box_ratio</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Adapts the bounding box of a cloud of points. Adaptation is an octal 2:1 decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Input points cloud</p></li>
<li><p><strong>box_ratio</strong> &#8211; ratio to scale the box</p></li>
</ul>
</dd>
</dl>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/adaptBox.py">adaptBox (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - adapt the bounding box of a point cloud (array) -</span>

<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Generator</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Intersector</span> <span class="k">as</span> <span class="nn">XOR</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cartHexa</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">adaptBox</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">box_ratio</span><span class="o">=</span><span class="mf">10.</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">closeCells</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="c1"># optional : to close the polyhedral cells</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">([</span><span class="n">m</span><span class="p">],</span> <span class="s1">&#39;out.plt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/adaptBoxPT.py">adaptBox (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - adapt the bounding box of a point cloud (array) -</span>

<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cartHexa</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">adaptBox</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">box_ratio</span><span class="o">=</span><span class="mf">10.</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">closeCells</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="c1"># optional : to close the polyhedral cells</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.createHMesh">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">createHMesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subdiv_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Builds a hierarchcial mesh structure for a and returns a hook</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Input points cloud</p></li>
<li><p><strong>subdiv_type</strong> (<em>int</em>) &#8211; type of adaptation, currently only isotropic (0).</p></li>
</ul>
</dd>
</dl>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/adaptCellsDynPT.py">createHMesh</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - dynamic adaptation</span>
<span class="c1">#</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>


<span class="n">mesh</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">))</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

<span class="n">source</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cartHexa</span><span class="p">((</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">))</span>

<span class="n">XOR</span><span class="o">.</span><span class="n">_setZonesAndJoinsUId</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

<span class="n">hmsh</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">createHMesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

<span class="n">senso</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">createSensor</span><span class="p">(</span><span class="n">hmsh</span><span class="p">)</span>
<span class="n">XOR</span><span class="o">.</span><span class="n">assignData2Sensor</span><span class="p">(</span><span class="n">senso</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">adaptCells</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">hmesh</span><span class="o">=</span><span class="n">hmsh</span><span class="p">,</span> <span class="n">sensor</span><span class="o">=</span><span class="n">senso</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">conformizeHMesh</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">hmsh</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">closeCells</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>


<span class="n">XOR</span><span class="o">.</span><span class="n">deleteHMesh</span><span class="p">(</span><span class="n">hmsh</span><span class="p">);</span>
<span class="n">XOR</span><span class="o">.</span><span class="n">deleteSensor</span><span class="p">(</span><span class="n">senso</span><span class="p">);</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.deleteHMesh">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">deleteHMesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hmesh</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Deletes a hierarchcial mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>hmesh</strong> (<em>hook</em>) &#8211; hmesh hook</p>
</dd>
</dl>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/adaptCellsDynPT.py">deleteHMesh</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - dynamic adaptation</span>
<span class="c1">#</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>


<span class="n">mesh</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">))</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

<span class="n">source</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cartHexa</span><span class="p">((</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">))</span>

<span class="n">XOR</span><span class="o">.</span><span class="n">_setZonesAndJoinsUId</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

<span class="n">hmsh</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">createHMesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

<span class="n">senso</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">createSensor</span><span class="p">(</span><span class="n">hmsh</span><span class="p">)</span>
<span class="n">XOR</span><span class="o">.</span><span class="n">assignData2Sensor</span><span class="p">(</span><span class="n">senso</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">adaptCells</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">hmesh</span><span class="o">=</span><span class="n">hmsh</span><span class="p">,</span> <span class="n">sensor</span><span class="o">=</span><span class="n">senso</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">conformizeHMesh</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">hmsh</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">closeCells</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>


<span class="n">XOR</span><span class="o">.</span><span class="n">deleteHMesh</span><span class="p">(</span><span class="n">hmsh</span><span class="p">);</span>
<span class="n">XOR</span><span class="o">.</span><span class="n">deleteSensor</span><span class="p">(</span><span class="n">senso</span><span class="p">);</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.conformizeHMesh">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">conformizeHMesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hooks</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Converts the basic element leaves of a hierarchical mesh (<cite>hooks</cite> is a list of pointers to hiearchical zones) to a conformal polyhedral mesh.
Each hierarchical zone is referring to a zone in the original Pytree <cite>t</cite>. So the mesh is replaced in the returned tree and the BCs/Joins/Fields are transferred.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>hooks</em>) &#8211; Input mesh</p></li>
<li><p><strong>hooks</strong> &#8211; list of pointers to hiearchical zones</p></li>
</ul>
</dd>
</dl>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/adaptCellsDynPT.py">conformizeHMesh</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - dynamic adaptation</span>
<span class="c1">#</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>


<span class="n">mesh</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">))</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

<span class="n">source</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cartHexa</span><span class="p">((</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">))</span>

<span class="n">XOR</span><span class="o">.</span><span class="n">_setZonesAndJoinsUId</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

<span class="n">hmsh</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">createHMesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

<span class="n">senso</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">createSensor</span><span class="p">(</span><span class="n">hmsh</span><span class="p">)</span>
<span class="n">XOR</span><span class="o">.</span><span class="n">assignData2Sensor</span><span class="p">(</span><span class="n">senso</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">adaptCells</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">hmesh</span><span class="o">=</span><span class="n">hmsh</span><span class="p">,</span> <span class="n">sensor</span><span class="o">=</span><span class="n">senso</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">conformizeHMesh</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">hmsh</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">closeCells</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>


<span class="n">XOR</span><span class="o">.</span><span class="n">deleteHMesh</span><span class="p">(</span><span class="n">hmsh</span><span class="p">);</span>
<span class="n">XOR</span><span class="o">.</span><span class="n">deleteSensor</span><span class="p">(</span><span class="n">senso</span><span class="p">);</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.createSensor">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">createSensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hmesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sensor_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smoothing_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">itermax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Creates a sensor and returns a hook on it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hmesh</strong> (<em>hook</em>) &#8211; hmesh hook</p></li>
<li><p><strong>sensor_type</strong> (<em>int</em>) &#8211; type of sensor. geometrical (0), xensor (1), nodal sensor (2), cell sensor (3)</p></li>
<li><p><strong>smoothing_type</strong> (<em>int</em>) &#8211; first-neighborhood (0), shell-neighborhood(1)</p></li>
<li><p><strong>itermax</strong> (<em>int</em>) &#8211; maximum nb of generations</p></li>
</ul>
</dd>
</dl>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/adaptCellsDynPT.py">createSensor</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - dynamic adaptation</span>
<span class="c1">#</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>


<span class="n">mesh</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">))</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

<span class="n">source</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cartHexa</span><span class="p">((</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">))</span>

<span class="n">XOR</span><span class="o">.</span><span class="n">_setZonesAndJoinsUId</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

<span class="n">hmsh</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">createHMesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

<span class="n">senso</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">createSensor</span><span class="p">(</span><span class="n">hmsh</span><span class="p">)</span>
<span class="n">XOR</span><span class="o">.</span><span class="n">assignData2Sensor</span><span class="p">(</span><span class="n">senso</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">adaptCells</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">hmesh</span><span class="o">=</span><span class="n">hmsh</span><span class="p">,</span> <span class="n">sensor</span><span class="o">=</span><span class="n">senso</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">conformizeHMesh</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">hmsh</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">closeCells</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>


<span class="n">XOR</span><span class="o">.</span><span class="n">deleteHMesh</span><span class="p">(</span><span class="n">hmsh</span><span class="p">);</span>
<span class="n">XOR</span><span class="o">.</span><span class="n">deleteSensor</span><span class="p">(</span><span class="n">senso</span><span class="p">);</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.assignData2Sensor">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">assignData2Sensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sensor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sensdata</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Assigns data to a sensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sensor</strong> (<em>hook</em>) &#8211; sensor hook</p></li>
<li><p><strong>sensdata</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>] </em><em>for sensor type 0 and 1. Numpy</em><em> of </em><em>integers for other sensors.</em>) &#8211; Data for the sensor</p></li>
</ul>
</dd>
</dl>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/adaptCellsDynPT.py">assignData2Sensor</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - dynamic adaptation</span>
<span class="c1">#</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>


<span class="n">mesh</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">))</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

<span class="n">source</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cartHexa</span><span class="p">((</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">))</span>

<span class="n">XOR</span><span class="o">.</span><span class="n">_setZonesAndJoinsUId</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

<span class="n">hmsh</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">createHMesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

<span class="n">senso</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">createSensor</span><span class="p">(</span><span class="n">hmsh</span><span class="p">)</span>
<span class="n">XOR</span><span class="o">.</span><span class="n">assignData2Sensor</span><span class="p">(</span><span class="n">senso</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">adaptCells</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">hmesh</span><span class="o">=</span><span class="n">hmsh</span><span class="p">,</span> <span class="n">sensor</span><span class="o">=</span><span class="n">senso</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">conformizeHMesh</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">hmsh</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">closeCells</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>


<span class="n">XOR</span><span class="o">.</span><span class="n">deleteHMesh</span><span class="p">(</span><span class="n">hmsh</span><span class="p">);</span>
<span class="n">XOR</span><span class="o">.</span><span class="n">deleteSensor</span><span class="p">(</span><span class="n">senso</span><span class="p">);</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.deleteSensor">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">deleteSensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sensor</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Deletes a sensor</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>sensor</strong> (<em>hook</em>) &#8211; sensor hook</p>
</dd>
</dl>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/adaptCellsDynPT.py">deleteSensor</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - dynamic adaptation</span>
<span class="c1">#</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>


<span class="n">mesh</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">))</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

<span class="n">source</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cartHexa</span><span class="p">((</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.2</span><span class="p">),</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">))</span>

<span class="n">XOR</span><span class="o">.</span><span class="n">_setZonesAndJoinsUId</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

<span class="n">hmsh</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">createHMesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

<span class="n">senso</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">createSensor</span><span class="p">(</span><span class="n">hmsh</span><span class="p">)</span>
<span class="n">XOR</span><span class="o">.</span><span class="n">assignData2Sensor</span><span class="p">(</span><span class="n">senso</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">adaptCells</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">hmesh</span><span class="o">=</span><span class="n">hmsh</span><span class="p">,</span> <span class="n">sensor</span><span class="o">=</span><span class="n">senso</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">conformizeHMesh</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">hmsh</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">closeCells</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>


<span class="n">XOR</span><span class="o">.</span><span class="n">deleteHMesh</span><span class="p">(</span><span class="n">hmsh</span><span class="p">);</span>
<span class="n">XOR</span><span class="o">.</span><span class="n">deleteSensor</span><span class="p">(</span><span class="n">senso</span><span class="p">);</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<hr class="docutils" />
<section id="metric-functions">
<h3>Metric Functions</h3>
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.edgeLengthExtrema">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">edgeLengthExtrema</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns the minimum edge length in a.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>a</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Input mesh</p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.volumes">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">volumes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns the cell volumes as a field (PyTree) or a numpy of floats.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>a</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Input mesh</p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.centroids">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">centroids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns the cell centroids as a points cloud.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>a</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Input mesh</p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.computeGrowthRatio">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">computeGrowthRatio</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vmin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>For each cell, the growth ratio with each of its neighbors is computed as the ratio of the biggest volume to the smallest one.</p>
<p>The maximum over all the neighbors is chosen:</p>
<p>Growth Ratio for Cell i  =  MAX_k ( MAX(vi, vk) / MIN(vi, vk) ) where k is a neighbor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Input mesh</p></li>
<li><p><strong>vmin</strong> (<em>float</em>) &#8211; volume threshold.</p></li>
</ul>
</dd>
</dl>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/computeGrowthRatio.py">computeGrowthRatio (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - Extract pathological cells (uncomputable or non-star) (array) -</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Intersector</span> <span class="k">as</span> <span class="nn">XOR</span>

<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2Arrays</span><span class="p">(</span><span class="s1">&#39;boolNG_M1.tp&#39;</span><span class="p">)</span>
<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2Arrays</span><span class="p">(</span><span class="s1">&#39;boolNG_M2.tp&#39;</span><span class="p">)</span>
<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">tol</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5e-3</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">booleanMinus</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span> <span class="n">M2</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">preserve_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">solid_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">agg_mode</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">aspect_ratio</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">computeGrowthRatio</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="n">aspect_ratio</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">center2Node</span><span class="p">(</span><span class="n">aspect_ratio</span><span class="p">)</span>

<span class="n">C</span><span class="o">.</span><span class="n">_addVars</span><span class="p">([</span><span class="n">m</span><span class="p">,</span> <span class="n">aspect_ratio</span><span class="p">])</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;out.plt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/computeGrowthRatioPT.py">computeGrowthRatio (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - Extract pathological cells (uncomputable or non-star) - (array)</span>

<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>

<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2PyTree</span><span class="p">(</span><span class="s1">&#39;boolNG_M1.tp&#39;</span><span class="p">)</span>
<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M1</span><span class="p">)</span>

<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2PyTree</span><span class="p">(</span><span class="s1">&#39;boolNG_M2.tp&#39;</span><span class="p">)</span>
<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M2</span><span class="p">)</span>

<span class="n">tol</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5e-3</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">booleanMinus</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span> <span class="n">M2</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">preserve_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">solid_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">agg_mode</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">t</span><span class="o">=</span><span class="n">XOR</span><span class="o">.</span><span class="n">computeGrowthRatio</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<hr class="docutils" />
<section id="extraction-functions">
<h3>Extraction Functions</h3>
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.extractPathologicalCells">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">extractPathologicalCells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neigh_level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Extracts cells that will potentially cause a failure when running a CFD solver. There are 4 zones upon exit, one for each pathology:</p>
<blockquote>
<div><ul class="simple">
<li><p>Non-centroid-star-shaped Cells</p></li>
<li><p>Cells having degenrated polygons for which the normal cannot be computed</p></li>
<li><p>Cells having degenrated polygons for a delaunay triangulation fails</p></li>
<li><p>Open Cells</p></li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Input mesh</p></li>
<li><p><strong>neigh_level</strong> (<em>int</em>) &#8211; Number of neighbor layers (surounding pathologies) to extract as well</p></li>
</ul>
</dd>
</dl>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/extractPathologicals.py">extractPathologicalCells (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - Extract pathological cells (uncomputable or non-star) - (array)</span>

<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Intersector</span> <span class="k">as</span> <span class="nn">XOR</span>

<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2Arrays</span><span class="p">(</span><span class="s1">&#39;boolNG_M1.tp&#39;</span><span class="p">)</span>
<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2Arrays</span><span class="p">(</span><span class="s1">&#39;boolNG_M2.tp&#39;</span><span class="p">)</span>
<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">tol</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5e-3</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">booleanMinus</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span> <span class="n">M2</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">preserve_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">solid_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">agg_mode</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c1">#C.convertArrays2File([m], &#39;i.plt&#39;)</span>

<span class="n">m</span><span class="o">=</span><span class="n">XOR</span><span class="o">.</span><span class="n">extractPathologicalCells</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># ask for 2 level of neighgbors</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;out.plt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/extractPathologicalsPT.py">extractPathologicalCells (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - Extract pathological cells (PyTree) -</span>
<span class="c1"># uncomputable or non-star</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>

<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2PyTree</span><span class="p">(</span><span class="s1">&#39;boolNG_M1.tp&#39;</span><span class="p">)</span>
<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M1</span><span class="p">)</span>

<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2PyTree</span><span class="p">(</span><span class="s1">&#39;boolNG_M2.tp&#39;</span><span class="p">)</span>
<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M2</span><span class="p">)</span>

<span class="n">tol</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5e-3</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">booleanMinus</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span> <span class="n">M2</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">preserve_right</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">solid_right</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">agg_mode</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">extractPathologicalCells</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># ask for 2 level of neighgbors</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;out.cgns&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.extractOuterLayers">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">extractOuterLayers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">discard_external</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Extracts prescribed outer cell layers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Input mesh</p></li>
<li><p><strong>N</strong> (<em>int</em>) &#8211; Number of layers to extract</p></li>
<li><p><strong>discard_external</strong> (<em>0</em><em> or </em><em>1</em>) &#8211; For volume mesh with holes (e.g. external flow), set it to 1 to extract only layers around bodies, or 0 to extract over all the outer polygons.</p></li>
</ul>
</dd>
</dl>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/extractOuters.py">extractOuterLayers (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - extractOuterLayers (array) -</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Intersector</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Generator</span> <span class="k">as</span> <span class="nn">G</span>

<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2Arrays</span><span class="p">(</span><span class="s1">&#39;boolNG_M1.tp&#39;</span><span class="p">)</span>
<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">conformizeNGon</span><span class="p">(</span><span class="n">M1</span><span class="p">);</span> <span class="n">M1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">M1</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">extractOuterLayers</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">discard_external</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s2">&quot;out.plt&quot;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/extractOutersPT.py">extractOuterLayers (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - extractOuterLayers (pyTree) -</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2PyTree</span><span class="p">(</span><span class="s1">&#39;boolNG_M1.tp&#39;</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">conformizeNGon</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="n">t</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">extractOuterLayers</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">discard_external</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">output_remaining</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;out.cgns&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.getCells">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">getCells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">are_face_ids</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns the cells in t1 having specified faces or cell ids.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Input mesh</p></li>
<li><p><strong>ids</strong> (<em>numpy</em><em> of </em><em>ints</em>) &#8211; face or cell ids</p></li>
<li><p><strong>are_face_ids</strong> (<em>boolean</em>) &#8211; Tells whether the ids are referring to faces or cells.</p></li>
</ul>
</dd>
</dl>
<p><em>Example of use:</em></p>
<p>See <a class="reference internal" href="#Intersector.getCollidingCells" title="Intersector.getCollidingCells"><code class="xref any py py-func docutils literal notranslate"><span class="pre">getCollidingCells</span></code></a> for an example.</p>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.getOverlappingFaces">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">getOverlappingFaces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">RTOL</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ps_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dir2</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Detects all the overlapping polygons in t1 and t2. Returns the result as a list sized as the number of zones in t1. Each entry gives 2 lists : the first is the pg ids in t1 ith-zone, the second is the pg ids in t2 (joined).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t1</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Input mesh</p></li>
<li><p><strong>t2</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Input mesh</p></li>
<li><p><strong>RTOL</strong> (<em>float</em>) &#8211; relative tolerance</p></li>
<li><p><strong>ps_min</strong> (<em>float</em>) &#8211; minimal dot product between normals of a pair of polygon to consider them as potentially overlapping.</p></li>
<li><p><strong>dir2</strong> (<em>tuple</em>) &#8211; given direction to compare t1&#8217;s faces with. If None, t2&#8217;s normals are used.</p></li>
</ul>
</dd>
</dl>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/getOverlappingFaces.py">getOverlappingFaces (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">Generator</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Transform</span> <span class="k">as</span> <span class="nn">T</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">I</span>
<span class="kn">import</span> <span class="nn">Intersector</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">KCore.test</span> <span class="k">as</span> <span class="nn">test</span>
<span class="kn">import</span> <span class="nn">Post</span> <span class="k">as</span> <span class="nn">P</span>

<span class="n">t1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">t1</span><span class="p">);</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mf">1.</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">t2</span><span class="p">);</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>

<span class="c1"># test 1 : volume/volume</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">getOverlappingFaces</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">RTOL</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">amax</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># create a list of polygon list (t1), one list per zone</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">agglomerateCellsWithSpecifiedFaces</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">([</span><span class="n">t</span><span class="p">],</span> <span class="s2">&quot;out.plt&quot;</span><span class="p">)</span>

<span class="c1">#test 2 : volume/surface</span>

<span class="n">t2</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">exteriorFaces</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">convertNGON2DToNGON3D</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>

<span class="n">res</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">getOverlappingFaces</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">RTOL</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">amax</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">agglomerateCellsWithSpecifiedFaces</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">([</span><span class="n">t</span><span class="p">],</span> <span class="s2">&quot;out1.plt&quot;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/getOverlappingFacesPT.py">getOverlappingFaces (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Transform.PyTree</span> <span class="k">as</span> <span class="nn">T</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Converter.Internal</span> <span class="k">as</span> <span class="nn">I</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">KCore.test</span> <span class="k">as</span> <span class="nn">test</span>
<span class="kn">import</span> <span class="nn">Post.PyTree</span> <span class="k">as</span> <span class="nn">P</span>

<span class="n">t1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">t1</span><span class="p">);</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mf">1.</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">t2</span><span class="p">);</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>

<span class="c1"># test 1 : volume/volume</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">getOverlappingFaces</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">RTOL</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">amax</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># create a list of polygon list (t1), one list per zone</span>
<span class="n">nb_zones</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
<span class="n">t1zones_pgids</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_zones</span><span class="p">):</span>
    <span class="n">t1zones_pgids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">agglomerateCellsWithSpecifiedFaces</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t1zones_pgids</span><span class="p">)</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;out.cgns&quot;</span><span class="p">)</span>

<span class="c1">#test 2 : volume/surface</span>

<span class="n">t2</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">exteriorFaces</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">convertNGON2DToNGON3D</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>

<span class="n">res</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">getOverlappingFaces</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">RTOL</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">amax</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="n">t1zones_pgids</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_zones</span><span class="p">):</span>
    <span class="n">t1zones_pgids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">agglomerateCellsWithSpecifiedFaces</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t1zones_pgids</span><span class="p">)</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;out1.cgns&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><em>Tips and Notes:</em></p>
<ul class="simple">
<li><p>When assembling 2 meshes m1 and m2 where m2 is priorized, to improve the assembly quality, do before calling the boolean union:</p></li>
</ul>
<ol class="arabic simple">
<li><p>getOverlappingFaces (m1, skin(m2)) where skin(m2) is the external polygonal skin of m2</p></li>
<li><p>agglomerateCellsWithSpecifiedFaces on m1 with the above list of polygons</p></li>
</ol>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.getCollidingCells">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">getCollidingCells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">RTOL</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Returns the list of cells in t1 and t2 that are colliding. Possible combinations of mesh types for (t1,t2) are (volume,volume), (volume,surface), (surface, polyline).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t1</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Input mesh</p></li>
<li><p><strong>t2</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Input mesh</p></li>
<li><p><strong>RTOL</strong> (<em>float</em>) &#8211; relative tolerance</p></li>
</ul>
</dd>
</dl>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/getCollidingCells.py">getCollidingCells (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">Generator</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Transform</span> <span class="k">as</span> <span class="nn">T</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">I</span>
<span class="kn">import</span> <span class="nn">Intersector</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">KCore.test</span> <span class="k">as</span> <span class="nn">test</span>
<span class="kn">import</span> <span class="nn">Post</span> <span class="k">as</span> <span class="nn">P</span>

<span class="n">t1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">t1</span><span class="p">);</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">3.</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">t2</span><span class="p">);</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>

<span class="n">res</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">getCollidingCells</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">RTOL</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">getCells</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">are_face_ids</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">([</span><span class="n">m</span><span class="p">],</span> <span class="s2">&quot;out.plt&quot;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/getCollidingCellsPT.py">getCollidingCells (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Transform.PyTree</span> <span class="k">as</span> <span class="nn">T</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Converter.Internal</span> <span class="k">as</span> <span class="nn">I</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">KCore.test</span> <span class="k">as</span> <span class="nn">test</span>
<span class="kn">import</span> <span class="nn">Post.PyTree</span> <span class="k">as</span> <span class="nn">P</span>

<span class="n">t1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">t1</span><span class="p">);</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cart</span><span class="p">((</span><span class="mf">1.</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">3.</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">t2</span><span class="p">);</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>

<span class="n">res</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">getCollidingCells</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">RTOL</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>

<span class="p">[</span><span class="n">ids_in1</span><span class="p">,</span><span class="n">ids_in2</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">getCells</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="p">[</span><span class="n">ids_in1</span><span class="p">],</span> <span class="n">are_face_ids</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s2">&quot;out.cgns&quot;</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="s2">&quot;t1.cgns&quot;</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="s2">&quot;t2.cgns&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<hr class="docutils" />
<section id="check-functions">
<h3>Check Functions</h3>
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.selfX">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">selfX</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Checks self-intersections in a mesh. Returns the first two cell indices that collide.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>a</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Input mesh</p>
</dd>
</dl>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/selfX.py">selfX (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - boolean difference (array) -</span>
<span class="kn">import</span> <span class="nn">Intersector</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Transform</span> <span class="k">as</span> <span class="nn">T</span>

<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2Arrays</span><span class="p">(</span><span class="s1">&#39;boolNG_M1.tp&#39;</span><span class="p">)</span>
<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">conformizeNGon</span><span class="p">(</span><span class="n">M1</span><span class="p">)</span>
<span class="n">M1</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">closeCells</span><span class="p">(</span><span class="n">M1</span><span class="p">)</span>


<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2Arrays</span><span class="p">(</span><span class="s1">&#39;boolNG_M2.tp&#39;</span><span class="p">)</span>
<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">conformizeNGon</span><span class="p">(</span><span class="n">M2</span><span class="p">)</span>
<span class="n">M2</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">closeCells</span><span class="p">(</span><span class="n">M2</span><span class="p">)</span>

<span class="n">tol</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5e-3</span>


<span class="n">M</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span><span class="n">M2</span><span class="p">)</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">selfX</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">([</span><span class="n">M</span><span class="p">],</span> <span class="s1">&#39;out.plt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/selfXPT.py">selfX (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - boolean difference (array) -</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Transform.PyTree</span> <span class="k">as</span> <span class="nn">T</span>

<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2PyTree</span><span class="p">(</span><span class="s1">&#39;boolNG_M1.tp&#39;</span><span class="p">)</span>
<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M1</span><span class="p">)</span>
<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">conformizeNGon</span><span class="p">(</span><span class="n">M1</span><span class="p">)</span>
<span class="n">M1</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">closeCells</span><span class="p">(</span><span class="n">M1</span><span class="p">)</span>


<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2PyTree</span><span class="p">(</span><span class="s1">&#39;boolNG_M2.tp&#39;</span><span class="p">)</span>
<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M2</span><span class="p">)</span>
<span class="n">M2</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">conformizeNGon</span><span class="p">(</span><span class="n">M2</span><span class="p">)</span>
<span class="n">M2</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">closeCells</span><span class="p">(</span><span class="n">M2</span><span class="p">)</span>

<span class="n">tol</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5e-3</span>


<span class="n">M</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">M1</span><span class="p">,</span><span class="n">M2</span><span class="p">)</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">selfX</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>

<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="s1">&#39;out.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.diffMesh">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">diffMesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a2</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Extracts the diff between 2 meshes. Returns 2 zones : one zone with the a1 cells that are not in a2, the second one is the reciprocal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a1</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Input mesh</p></li>
<li><p><strong>a2</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Input mesh</p></li>
</ul>
</dd>
</dl>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/diffMesh.py">diffMesh (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - boolean diffSurf (array) -</span>
<span class="kn">import</span> <span class="nn">Generator</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Geom</span> <span class="k">as</span> <span class="nn">D</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Intersector</span> <span class="k">as</span> <span class="nn">XOR</span>

<span class="c1"># octree</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">sphere</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mf">1.</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span> <span class="n">snear</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">octree</span><span class="p">([</span><span class="n">s</span><span class="p">],[</span><span class="n">snear</span><span class="p">],</span> <span class="n">dfar</span><span class="o">=</span><span class="mf">5.</span><span class="p">,</span> <span class="n">balancing</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">ratio</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># ngon converion</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="c1"># ngon conformization</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">conformizeNGon</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="n">t</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="c1"># ngon close cells</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">closeCells</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="c1">#t = XOR.reorientExternalFaces(t)</span>

<span class="c1"># ngon converion of the sphere</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="c1"># ngon converion to the nuga format</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">convertNGON2DToNGON3D</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="c1">#s = XOR.reorientExternalFaces(s)</span>

<span class="c1"># Boolean operation</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">diffSurf</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">preserve_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">agg_mode</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># agg_mode=2 : full mode aggregation</span>

<span class="n">xa</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">agglomerateSmallCells</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">10.</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">diffMesh</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">xa</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertArrays2File</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;diffM.plt&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/diffMeshPT.py">diffMesh (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - boolean diffSurf (array) -</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Geom.PyTree</span> <span class="k">as</span> <span class="nn">D</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>

<span class="c1"># octree</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">D</span><span class="o">.</span><span class="n">sphere</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mf">1.</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span> <span class="n">snear</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">octree</span><span class="p">([</span><span class="n">s</span><span class="p">],[</span><span class="n">snear</span><span class="p">],</span> <span class="n">dfar</span><span class="o">=</span><span class="mf">5.</span><span class="p">,</span> <span class="n">balancing</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">ratio</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># ngon conversion</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="c1"># ngon conformization</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">conformizeNGon</span><span class="p">(</span><span class="n">t</span><span class="p">);</span> <span class="n">t</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="c1"># ngon close cells</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">closeCells</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="c1">#t = XOR.reorientExternalFaces(t)</span>

<span class="c1"># ngon converion of the sphere</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="c1"># ngon converion to the nuga format</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">convertNGON2DToNGON3D</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="c1">#s = XOR.reorientExternalFaces(s)</span>

<span class="c1"># Boolean operation</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">diffSurf</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">preserve_right</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">agg_mode</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># agg_mode=2 : full mode aggregation</span>

<span class="n">xa</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">agglomerateSmallCells</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">10.</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">diffMesh</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">xa</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">convertPyTree2File</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;diffM.cgns&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.checkCellsClosure">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">checkCellsClosure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Checks that input mesh cells are closed, i.e. each cell&#8217; edge is shared by exactly two polygons.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>a</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Input mesh</p>
</dd>
</dl>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/checkCellsClosure.py">checkCellsClosure (array)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - boolean reorientExternalFaces (array) -</span>
<span class="kn">import</span> <span class="nn">Generator</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Converter</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Intersector</span> <span class="k">as</span> <span class="nn">XOR</span>


<span class="n">a</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">cartHexa</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.2</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="n">err</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">checkCellsClosure</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/checkCellsClosurePT.py">checkCellsClosure (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - boolean checkCellsClosure (pyTree) -</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>

<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2PyTree</span><span class="p">(</span><span class="s1">&#39;boolNG_M1.tp&#39;</span><span class="p">)</span>
<span class="n">M1</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">M1</span><span class="p">)</span>

<span class="n">err</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">checkCellsClosure</span><span class="p">(</span><span class="n">M1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.checkCellsFlux">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">checkCellsFlux</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Computes the cell fluxes using the ParentElement elsA&#8217;s node for orientation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>a</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Input mesh</p>
</dd>
</dl>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/checkCellsFluxPT.py">checkCellsFlux (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - selectCells (pyTree) -</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Converter.Internal</span> <span class="k">as</span> <span class="nn">I</span>


<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2PyTree</span><span class="p">(</span><span class="s1">&#39;boolNG_M1.tp&#39;</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">closeCells</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

<span class="n">I</span><span class="o">.</span><span class="n">_createElsaHybrid</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">methodPE</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">XOR</span><span class="o">.</span><span class="n">checkCellsFlux</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.checkCellsVolume">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">checkCellsVolume</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Computes the minimum volume using the ParentElement elsA&#8217;s node for orientation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>a</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Input mesh</p>
</dd>
</dl>
<p><em>Example of use:</em></p>
<ul class="simple">
<li><p><a class="reference external" href="Examples/Intersector/checkCellsVolumePT.py">checkCellsVolume (pyTree)</a>:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># - boolean checkCellsClosure (array) -</span>
<span class="kn">import</span> <span class="nn">Generator.PyTree</span> <span class="k">as</span> <span class="nn">G</span>
<span class="kn">import</span> <span class="nn">Converter.PyTree</span> <span class="k">as</span> <span class="nn">C</span>
<span class="kn">import</span> <span class="nn">Intersector.PyTree</span> <span class="k">as</span> <span class="nn">XOR</span>
<span class="kn">import</span> <span class="nn">Geom.PyTree</span> <span class="k">as</span> <span class="nn">D</span>
<span class="kn">import</span> <span class="nn">Converter.Internal</span> <span class="k">as</span> <span class="nn">I</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertFile2PyTree</span><span class="p">(</span><span class="s1">&#39;boolNG_M1.tp&#39;</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">convertArray2NGon</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">closeCells</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

<span class="n">I</span><span class="o">.</span><span class="n">_createElsaHybrid</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">methodPE</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">err</span> <span class="o">=</span> <span class="n">XOR</span><span class="o">.</span><span class="n">checkCellsVolume</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<hr class="docutils" />
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.checkForDegenCells">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">checkForDegenCells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Checks if there are any cell with less than 4 faces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>a</strong> (<em>[</em><em>array</em><em>, </em><em>list</em><em> of </em><em>arrays</em><em>] or </em><em>[</em><em>pyTree</em><em>, </em><em>base</em><em>, </em><em>zone</em><em>, </em><em>list</em><em> of </em><em>zones</em><em>]</em>) &#8211; Input mesh</p>
</dd>
</dl>
</dd></dl>

</section>
<hr class="docutils" />
<section id="conversion-functions">
<h3>Conversion Functions</h3>
<dl class="py function">
<dt class="sig sig-object py" id="Intersector.convertNGON2DToNGON3D">
<span class="sig-prename descclassname"><span class="pre">Intersector.</span></span><span class="sig-name descname"><span class="pre">convertNGON2DToNGON3D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span></dt>
<dd></dd></dl>

<p>Converts a polygon surface stored in the Cassiopee NGON format (Face/Edge) to a Face/Node format.</p>
<hr class="docutils" />
<div class="toctree-wrapper compound">
</div>
</section>
</section>
<section id="index">
<h2>Index</h2>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="#">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Intersector: Mesh-Intersection-Based Services</a><ul>
<li><a class="reference internal" href="#preamble">Preamble</a></li>
<li><a class="reference internal" href="#list-of-functions">List of functions</a></li>
<li><a class="reference internal" href="#contents">Contents</a></li>
<li><a class="reference internal" href="#index">Index</a></li>
</ul>
</li>
</ul>

  </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><a  href="Intersector.pdf" target="_self">Download pdf version</a>
<p></p>
<head>
<style>
#myBtn {
  display: none;
  position: fixed;
  bottom: 20px;
  right: 30px;
  z-index: 99;
  border: none;
  outline: none;
  background-color: #282a35;
  cursor: pointer;
  padding: 15px;
  border-radius: 10px;
}

#myBtn:hover {
  background-color: rgb(26,85,85);
}

#myImg:hover {
  opacity: 50%;
}

</style>
</head>

<button onclick="topFunction()" id="myBtn" title="Go to top"><img src="./_static/icon.png" width="20" height="20"></button>

<script>
const targetDiv = document.getElementsByClassName('sphinxsidebarwrapper')[0];

const link = document.createElement('a');
link.href = "../index.html";

const newImage = document.createElement('img');
newImage.src = '../Images/CassiopeeLogo.png';
newImage.id = 'myImg';
newImage.style.width = '80%';
newImage.style.height = 'auto';
newImage.style.border = 'none';
newImage.style.borderRadius = '0px';
newImage.style.marginLeft = '18px';
newImage.style.marginBottom = '50px';

// Append the image to the div
link.appendChild(newImage);
targetDiv.prepend(link);
  
// When the user scrolls down 20px from the top of the document, show the button
window.onscroll = scrollFunction;
function scrollFunction() {
    if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
        document.getElementById("myBtn").style.display = "block";
    } else {
        document.getElementById("myBtn").style.display = "none";
    }
}

// When the user clicks on the button, scroll to the top of the document
function topFunction() {
    document.body.scrollTop = 0;
    document.documentElement.scrollTop = 0;
}

// When the window is too small, hide the sidebar
window.onresize = resizeFunction;
window.onload = resizeFunction;
function resizeFunction() {
  var bodyWidth = document.bodyWidth;
  if (window.outerWidth < 1000) {
        document.getElementsByClassName("sphinxsidebar")[0].style.visibility = "hidden";
        document.getElementById("myBtn").style.visibility = "visible";
        document.getElementsByClassName("body")[0].style.marginLeft = "-170px";
        document.getElementsByClassName("body")[0].style.maxWidth = "135%";
        document.getElementsByClassName("body")[0].style.paddingLeft = "30px";    
    } else {
        document.getElementsByClassName("sphinxsidebar")[0].style.visibility = "visible";
        document.getElementsByClassName("body")[0].style.marginLeft = "130px";
        document.getElementsByClassName("body")[0].style.maxWidth = "80%";
        document.getElementsByClassName("body")[0].style.paddingLeft = "0px";    
  }
}

</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">Intersector 4.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Intersector: Mesh-Intersection-Based Services</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    </div>
  </body>
</html>
